" vim: set ft=vim ts=4 sw=4 sts=4 foldmethod=marker :
" ----------------------------------------
" VIMè¨­å®šãƒ•ã‚¡ã‚¤ãƒ«
" ----------------------------------------
" @Author Hajime <mail@hazime.org>
" @Update 2015.06.22
" ----------------------------------------

nnoremap rv :<C-u>source ~/.vimrc<CR>

" NeoBundleç”¨ã®ã‚¹ã‚¿ãƒ¼ãƒˆã‚¢ãƒƒãƒ— {{{
" ----------------------------------------

filetype plugin indent off

if has('vim_starting')
  set runtimepath+=~/.dotfiles/vim/third/neobundle.vim/
endif

call neobundle#begin(expand('~/.dotfiles/vim/bundle/'))


" }}}

" Auto Command {{{
function! s:RestoreCursorPostion()
    if line("'\"") <= line("$")
        normal! g`"
        return 1
    endif
endfunction

augroup NoraAutoCmd
  autocmd!
  autocmd BufWinEnter * call s:RestoreCursorPostion()
augroup END

" }}}

" ãƒ—ãƒ¬ãƒ•ã‚£ãƒƒã‚¯ã‚¹ã®è¨­å®š {{{
nmap s <Nop>
nnoremap [nora] <NOP>
nmap s <ESC>[nora]
nmap <C-f> <ESC>[nora]
imap <c-f> <ESC>[nora]

nnoremap [nora:mode] <NOP>
nmap m [nora:mode]


nnoremap [nora:ext] <Nop>
nmap <space> <ESC>[nora:ext]

nnoremap [search] <nop>
nmap [nora]g <esc>[search]
" }}}

" ãƒ™ãƒ¼ã‚·ãƒƒã‚¯ã‚»ãƒƒãƒ†ã‚£ãƒ³ã‚° {{{

" VIã¨ã®äº’æ›æ€§ã‚’ä¿ãŸãªã„
set nocompatible

" ãƒ•ã‚¡ã‚¤ãƒ«ãƒ­ã‚±ãƒ¼ã‚·ãƒ§ãƒ³
set directory=~/.vim.tmp//
set backupdir=~/.vim.tmp//

" Swapã¯ä½¿ã‚ãªã„
set noswapfile
" ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã¯ä½¿ã†
set backup

" VIMã‚³ãƒãƒ³ãƒ‰å±¥æ­´ä¿æŒæ•°
set viminfo='100
" VIMãƒ¬ã‚¸ã‚¹ãƒˆãƒªä¿æŒæ•°
set viminfo+="1000
" VIMINFOä¿å­˜ãƒ•ã‚¡ã‚¤ãƒ«
set viminfo+=n~/.vim.info

"
" åŒæ™‚ç·¨é›†ãŒç™ºç”Ÿã—ãŸæ™‚ã®æŒ™å‹•
"

" ä»–ã®å ´æ‰€ã§æ›´æ–°ã•ã‚ŒãŸã‚‰è‡ªå‹•çš„ã«èª­ã¿è¾¼ã‚€
set autoread

" ãƒãƒƒã‚¯ã‚¹ãƒšãƒ¼ã‚¹ã§å‰Šé™¤å¯èƒ½ãªã‚‚ã®ã‚’å¢—ã‚„ã™
set backspace=start,eol,indent


"
" æ¤œç´¢ã®æŒ™å‹•
"

" æ¤œç´¢æ™‚ã«å¤§æ–‡å­—å°æ–‡å­—ã‚’ç„¡è¦–
set ignorecase

" ãŸã ã—ã€æ¤œç´¢æ–‡å­—ã«å¤§æ–‡å­—å°æ–‡å­—ãŒã‚ã‚Œã°ç„¡è¦–ã—ãªã„
set smartcase  " do not ignore capital when search words includs both

" æ¤œç´¢æ–‡å­—ã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆã—ãªã„
set nohlsearch

"
" TTYã®è¨­å®š
"
set lazyredraw
set ttyfast

" ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦å¹…ã§æŠ˜ã‚Šè¿”ã™
set nowrap

" å›ºå®šæŠ˜ã‚Šè¿”ã—æ–‡å­—å¹…ã‚’æŒãŸãªã„
set textwidth=0

" è¡Œç•ªå·ã‚’è¡¨ç¤ºã™ã‚‹
set number

set scrolloff=16

" }}}

" æŠ˜ã‚ŠãŸãŸã¿ {{{
"set foldtext=FoldCCtext()
set foldcolumn=3
set fillchars=vert:\|
hi Folded gui=bold term=standout ctermbg=LightGrey ctermfg=DarkBlue guibg=Grey30 guifg=Grey80
hi FoldColumn gui=bold term=standout ctermbg=LightGrey ctermfg=DarkBlue guibg=Grey guifg=DarkBlue

" }}}

" ã‚¿ãƒ–ç³»ã®è¨­å®š {{{
set tabstop=4
set softtabstop=4
set shiftwidth=4
set expandtab
" }}}

" ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒ©ã‚¤ãƒ³ã®è¨­å®š {{{
set laststatus=2
"set showmode
set noshowmode
set showcmd
set wildmenu
set ruler

NeoBundle 'itchyny/lightline.vim'
" wonbat solarized landscape
let g:lightline = {
      \ 'colorscheme': 'jellybeans',
      \ 'component': {
      \   'readonly': '%{&readonly?"î‚¢":""}',
      \ },
      \ 'separator': { 'left': 'î‚°', 'right': 'î‚²' },
      \ 'subseparator': { 'left': 'î‚±', 'right': 'î‚³' }
      \ }
 
let g:lightline = {
      \ 'colorscheme': 'jellybeans',
      \ 'active': {
      \   'left': [ [ 'mode', 'paste' ], [ 'fugitive', 'filename' ], ['ctrlpmark'] ],
      \   'right': [ [ 'syntastic', 'lineinfo' ], ['percent'], [ 'fileformat', 'fileencoding', 'filetype' ] ]
      \ },
      \ 'component': {
      \   'readonly': '%{&readonly?"î‚¢":""}',
      \ },
      \ 'component_function': {
      \   'fugitive': 'MyFugitive',
      \   'filename': 'MyFilename',
      \   'fileformat': 'MyFileformat',
      \   'filetype': 'MyFiletype',
      \   'fileencoding': 'MyFileencoding',
      \   'mode': 'MyMode',
      \   'ctrlpmark': 'CtrlPMark',
      \ },
      \ 'component_expand': {
      \   'syntastic': 'SyntasticStatuslineFlag',
      \ },
      \ 'component_type': {
      \   'syntastic': 'error',
      \ },
      \ 'separator': { 'left': 'î‚°', 'right': 'î‚²' },
      \ 'subseparator': { 'left': 'î‚±', 'right': 'î‚³' }
      \ }

function! MyModified()
  return &ft =~ 'help' ? '' : &modified ? '+' : &modifiable ? '' : '-'
endfunction

function! MyReadonly()
  return &ft !~? 'help' && &readonly ? 'RO' : ''
endfunction

function! MyFilename()
  let fname = expand('%:t')
  return fname == 'ControlP' ? g:lightline.ctrlp_item :
        \ fname == '__Tagbar__' ? g:lightline.fname :
        \ fname =~ '__Gundo\|NERD_tree' ? '' :
        \ &ft == 'vimfiler' ? vimfiler#get_status_string() :
        \ &ft == 'unite' ? unite#get_status_string() :
        \ &ft == 'vimshell' ? vimshell#get_status_string() :
        \ ('' != MyReadonly() ? MyReadonly() . ' ' : '') .
        \ ('' != fname ? fname : '[No Name]') .
        \ ('' != MyModified() ? ' ' . MyModified() : '')
endfunction

function! MyFugitive()
  try
    if expand('%:t') !~? 'Tagbar\|Gundo\|NERD' && &ft !~? 'vimfiler' && exists('*fugitive#head')
      let mark = ''  " edit here for cool mark
      let _ = fugitive#head()
      return strlen(_) ? mark._ : ''
    endif
  catch
  endtry
  return ''
endfunction

function! MyFileformat()
  return winwidth(0) > 70 ? &fileformat : ''
endfunction

function! MyFiletype()
  return winwidth(0) > 70 ? (strlen(&filetype) ? &filetype : 'no ft') : ''
endfunction

function! MyFileencoding()
  return winwidth(0) > 70 ? (strlen(&fenc) ? &fenc : &enc) : ''
endfunction

function! MyMode()
  let fname = expand('%:t')
  return fname == '__Tagbar__' ? 'Tagbar' :
        \ fname == 'ControlP' ? 'CtrlP' :
        \ fname == '__Gundo__' ? 'Gundo' :
        \ fname == '__Gundo_Preview__' ? 'Gundo Preview' :
        \ fname =~ 'NERD_tree' ? 'NERDTree' :
        \ &ft == 'unite' ? 'Unite' :
        \ &ft == 'vimfiler' ? 'VimFiler' :
        \ &ft == 'vimshell' ? 'VimShell' :
        \ winwidth(0) > 60 ? lightline#mode() : ''
endfunction

function! CtrlPMark()
  if expand('%:t') =~ 'ControlP'
    call lightline#link('iR'[g:lightline.ctrlp_regex])
    return lightline#concatenate([g:lightline.ctrlp_prev, g:lightline.ctrlp_item
          \ , g:lightline.ctrlp_next], 0)
  else
    return ''
  endif
endfunction

let g:ctrlp_status_func = {
  \ 'main': 'CtrlPStatusFunc_1',
  \ 'prog': 'CtrlPStatusFunc_2',
  \ }

function! CtrlPStatusFunc_1(focus, byfname, regex, prev, item, next, marked)
  let g:lightline.ctrlp_regex = a:regex
  let g:lightline.ctrlp_prev = a:prev
  let g:lightline.ctrlp_item = a:item
  let g:lightline.ctrlp_next = a:next
  return lightline#statusline(0)
endfunction

function! CtrlPStatusFunc_2(str)
  return lightline#statusline(0)
endfunction

let g:tagbar_status_func = 'TagbarStatusFunc'

function! TagbarStatusFunc(current, sort, fname, ...) abort
    let g:lightline.fname = a:fname
  return lightline#statusline(0)
endfunction

augroup AutoSyntastic
  autocmd!
  autocmd BufWritePost *.c,*.cpp call s:syntastic()
augroup END
function! s:syntastic()
  SyntasticCheck
  call lightline#update()
endfunction

let g:unite_force_overwrite_statusline = 0
let g:vimfiler_force_overwrite_statusline = 0
let g:vimshell_force_overwrite_statusline = 0

" set statusline=%<     " è¡ŒãŒé•·ã™ãã‚‹ã¨ãã«åˆ‡ã‚Šè©°ã‚ã‚‹ä½ç½®
" set statusline+=[%n]  " ãƒãƒƒãƒ•ã‚¡ç•ªå·
" set statusline+=%m    " %m ä¿®æ­£ãƒ•ãƒ©ã‚°
" set statusline+=%r    " %r èª­ã¿è¾¼ã¿å°‚ç”¨ãƒ•ãƒ©ã‚°
" set statusline+=%h    " %h ãƒ˜ãƒ«ãƒ—ãƒãƒƒãƒ•ã‚¡ãƒ•ãƒ©ã‚°
" set statusline+=%w    " %w ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒ•ãƒ©ã‚°
" set statusline+=%{'['.(&fenc!=''?&fenc:&enc).':'.&ff.']'}  " fencã¨ffã‚’è¡¨ç¤º
" set statusline+=%y    " ãƒãƒƒãƒ•ã‚¡å†…ã®ãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚¿ã‚¤ãƒ—
" set statusline+=\     " ç©ºç™½ã‚¹ãƒšãƒ¼ã‚¹
" if winwidth(0) >= 130
"     set statusline+=%F    " ãƒãƒƒãƒ•ã‚¡å†…ã®ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ•ãƒ«ãƒ‘ã‚¹
" else
"     set statusline+=%t    " ãƒ•ã‚¡ã‚¤ãƒ«åã®ã¿
" endif
" set statusline+=%=    " å·¦å¯„ã›é …ç›®ã¨å³å¯„ã›é …ç›®ã®åŒºåˆ‡ã‚Š
" set statusline+=%{fugitive#statusline()}  " Gitã®ãƒ–ãƒ©ãƒ³ãƒåã‚’è¡¨ç¤º
" set statusline+=\ \   " ç©ºç™½ã‚¹ãƒšãƒ¼ã‚¹2å€‹
" set statusline+=%1l   " ä½•è¡Œç›®ã«ã‚«ãƒ¼ã‚½ãƒ«ãŒã‚ã‚‹ã‹
" set statusline+=/
" set statusline+=%L    " ãƒãƒƒãƒ•ã‚¡å†…ã®ç·è¡Œæ•°
" set statusline+=,
" set statusline+=%c    " ä½•åˆ—ç›®ã«ã‚«ãƒ¼ã‚½ãƒ«ãŒã‚ã‚‹ã‹
" set statusline+=%V    " ç”»é¢ä¸Šã®ä½•åˆ—ç›®ã«ã‚«ãƒ¼ã‚½ãƒ«ãŒã‚ã‚‹ã‹
" set statusline+=\ \   " ç©ºç™½ã‚¹ãƒšãƒ¼ã‚¹2å€‹
" set statusline+=%P    " ãƒ•ã‚¡ã‚¤ãƒ«å†…ã®ä½•ï¼…ã®ä½ç½®ã«ã‚ã‚‹ã‹

" }}}

" æ—¥æœ¬èªé–¢é€£ {{{

" æ–‡å­—ã‚³ãƒ¼ãƒ‰åˆ¤å®šé †åº
set fileencodings=utf-8,euc-jp,iso-2022-jp,cp932

" }}}

" ã‚·ãƒ³ã‚¿ãƒƒã‚¯ã‚¹ {{{
syntax enable
" }}}

" NeoBundle {{{
NeoBundleFetch 'Shougo/neobundle.vim'

" Vim Procã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
NeoBundle 'Shougo/vimproc',{'build': 
\ {
\   'windows': 'make -f make_windows.mak',
\   'cygwin': 'make -f make_cygwin.mak',
\   'mac': 'make -f make_mac.mak',
\   'unix': 'make -f make_unix.mak',
\ }
\}

NeoBundleLazy 'thinca/vim-quickrun', {
            \ 'autoload' : {
            \     'commands' : [ 'QuickRun' ]
            \  }
            \}

NeoBundleLazy 'Shougo/vimfiler.vim', {
\   'autoload' : { 'commands' : [ 'VimFiler', 'VimFilerTab', 'VimFilerExplorer', 'VimFilerBufferDir', 'VimFilerCreate' ] },
\   'depends': [ 'Shougo/unite.vim' ],
\ }

NeoBundleLazy 'Shougo/unite.vim' , {
\   'autoload' : { 'commands' : [ 'Unite' ] }
\ }

" VimShell
NeoBundleLazy 'Shougo/vimshell', {'depends': ['Shougo/vimproc']}


" Uniteãƒ—ãƒ©ã‚°ã‚¤ãƒ³
NeoBundleLazy 'Shougo/unite-outline'
" NeoBundleLazy 'ujihisa/unite-colorscheme'
NeoBundleLazy 'tacroe/unite-mark'
NeoBundleLazy 'osyo-manga/unite-fold'
" NeoBundleLazy 'taka84u9/unite-git'
" NeoBundleLazy 'thinca/vim-unite-history'
" NeoBundleLazy 'kannokanno/unite-dwm'
NeoBundleLazy 'tsukkee/unite-tag'


NeoBundleLazy 'thinca/vim-ref', {
\ 'autoload' : {'commands': [ 'Ref' ] },
\ 'depends' : ["mfumi/ref-dicts-en"]
\}
NeoBundleLazy 'mfumi/ref-dicts-en'

"
" ãƒ¡ãƒ¢å¸³
"
" @See https://sites.google.com/site/fudist/Home/qfixhowm/install
NeoBundleLazy 'fuenor/qfixgrep'
NeoBundleLazy 'fuenor/qfixhowm'
NeoBundleLazy "osyo-manga/unite-qfixhowm"


NeoBundleLazy "sjl/gundo.vim", {"autoload": {"commands": ['GundoToggle'],}}
NeoBundleLazy 'majutsushi/tagbar', {"autload": {"commands": ["TagbarToggle"],}}

NeoBundleLazy 'plasticboy/vim-markdown', {"autoload": {"filetypes": ["markdown"]}}

" ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆã‚’ã‚ã‹ã‚Šã‚„ã™ãã™ã‚‹
NeoBundleLazy  'nathanaelkane/vim-indent-guides'

" VimTemplate
NeoBundleLazy "thinca/vim-template"


" ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªå˜ä½ã§ã®vimrcã‚’æœ‰åŠ¹ã«ã™ã‚‹
NeoBundleLazy 'thinca/vim-localrc'

" ctagsã‚’è‡ªå‹•åŒ–
NeoBundleLazy 'soramugi/auto-ctags.vim'

"
" ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ç”¨
"
" HTML5ã‚·ãƒ³ã‚¿ãƒƒã‚¯ã‚¹ã‚’æœ‰åŠ¹ã«ã™ã‚‹
NeoBundleLazy 'othree/html5.vim.git', {"autoload": {"filetypes": ['html']}}

" CoffeeScriptç”¨ãƒ—ãƒ©ã‚°ã‚¤ãƒ³
NeoBundleLazy 'kchmck/vim-coffee-script', {"autoload": {"filetype": ["coffee"]}}

" Align
NeoBundleLazy 'h1mesuke/vim-alignta.git', {"autoload": {"commands": ["Align"]}}

" TagList
NeoBundleLazy 'taglist.vim'

" ã‚¿ã‚°ã‚¸ãƒ£ãƒ³ãƒ—
NeoBundleLazy  'szw/vim-tags'

"Dockerfile Syntax
NeoBundleLazy 'ekalinin/Dockerfile.vim', {"autoload": {"filetype": ["dockerfile"]}}

"Vagrant Syntax
NeoBundleLazy 'markcornick/vim-vagrant', {"autoload": {"filetype": ["vagrantfile"]}}

"Tmux Syntax
NeoBundleLazy 'Keithbsmiley/tmux.vim', {"autoload": {"filetype": ["tmux"]}}

" Powerline
NeoBundleLazy 'Lokaltog/powerline', { 'rtp' : 'powerline/bindings/vim' }
NeoBundleLazy 'Lokaltog/powerline-fontpatcher'

" HTMLé–‰ã˜ã‚¿ã‚°å¾Œã®ã‚³ãƒ¡ãƒ³ãƒˆã‚’,tã§å…¥åŠ›
NeoBundleLazy 'haya14busa/endtagcomment.vim', {"autoload": {"filetype": ["html"]}}

" ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆç®¡ç†
" NeoBundle 'project.vim'
NeoBundleLazy 'kien/ctrlp.vim', {"autoload": {"commands": ["CtrlP", "CtrlPMRUFiles"]}}

" ãƒ¡ãƒ¢
NeoBundleLazy 'glidenote/memolist.vim', {"autoload": {"commands": ["MemoList"]}}

" }}}

" è¨­å®š {{{
NeoBundle 'kana/vim-textobj-user'

" Submoduleã‚’æœ‰åŠ¹ã«ã™ã‚‹
NeoBundle  'kana/vim-submode'

" Gitã‚’ä¾¿åˆ©ã«ä½¿ã†
NeoBundle 'tpope/vim-fugitive'

" ã‚³ãƒ¡ãƒ³ãƒˆON/OFFã‚’æ‰‹è»½ã«å®Ÿè¡Œ (gcc)
NeoBundle 'tomtom/tcomment_vim'

" Tabå˜ä½ã§ã®cdã‚’æœ‰åŠ¹ã«ã™ã‚‹
NeoBundle 'kana/vim-tabpagecd'

" ã‚«ãƒ©ãƒ¼ã‚¹ã‚­ãƒ¼ãƒ
NeoBundle 'nanotech/jellybeans.vim'
let s:bundle = neobundle#get('jellybeans.vim')
function! s:bundle.hooks.on_source(bundle)
    colorscheme jellybeans
endfunction

" Undoã‚’ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‰ã˜ãŸå¾Œã‚‚æœ‰åŠ¹ã«ã™ã‚‹
if has('persistent_undo')
    set undofile
    set undodir=$HOME/.vim.tmp
endif 

" ã‚­ãƒ¼ãƒã‚¤ãƒ³ãƒ‰ {{{

" é–“é•ãˆãã†ãªãƒã‚¤ãƒ³ãƒ‰ã‚’èª¿æ•´(äº‹æ•…ã®ç´ ) {{{
nnoremap ZZ <Nop>
nnoremap ZQ <Nop>
nnoremap Q <Nop>
inoremap <F1> <ESC>
nnoremap <F1> <ESC>
vnoremap <F1> <ESC>
nnoremap ; :
cmap w1 w! 
cmap q1 q! 
" }}}

" VIã‚’ã‚‚ã£ã¨ç›´æ„Ÿçš„ã«ã™ã‚‹ {{{
nnoremap j gj
nnoremap k gk
nnoremap gj j
nnoremap gk k
inoremap jj <ESC>

" ã‚«ãƒ¼ã‚½ãƒ«ä¸‹ã®å˜èªã‚’ * ã§æ¤œç´¢
vnoremap <silent> * "vy/\V<C-r>=substitute(escape(@v, '\/'), "\n", '\\n', 'g')<CR><CR>

" æ¤œç´¢å¾Œã«ã‚¸ãƒ£ãƒ³ãƒ—ã—ãŸéš›ã«æ¤œç´¢å˜èªã‚’ç”»é¢ä¸­å¤®ã«æŒã£ã¦ãã‚‹
nnoremap n nzz
nnoremap N Nzz
nnoremap * *zz
nnoremap # #zz
nnoremap g* g*zz
nnoremap g# g#zz

" vã‚’äºŒå›ã§è¡Œæœ«ã¾ã§é¸æŠ
vnoremap v $h

set showmatch           " å¯¾å¿œã™ã‚‹æ‹¬å¼§ãªã©ã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆè¡¨ç¤ºã™ã‚‹
set matchtime=3         " å¯¾å¿œæ‹¬å¼§ã®ãƒã‚¤ãƒ©ã‚¤ãƒˆè¡¨ç¤ºã‚’3ç§’ã«ã™ã‚‹
" å¯¾å¿œæ‹¬å¼§ã«'<'ã¨'>'ã®ãƒšã‚¢ã‚’è¿½åŠ 
set matchpairs& matchpairs+=<:>
" ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆä¸å¯è¦–æ–‡å­—ã¯ç¾ã—ããªã„ã®ã§Unicodeã§ç¶ºéº—ã«
set listchars=tab:Â»-,trail:-,extends:Â»,precedes:Â«,nbsp:%,eol:â†²
" }}}

" ãƒã‚¦ã‚¹ã®è¨­å®š {{{

" ãƒã‚¦ã‚¹ã®æœ‰åŠ¹ç„¡åŠ¹
nnoremap <F3> :call ToggleMouse()<CR>
inoremap <F3> :call ToggleMouse()<CR>
function! ToggleMouse()
	if &mouse == 'a'
		set mouse =
		echo "Mouse usage disabled"
	else
		set mouse=a
		echo "Mouse usage enabled"
	endif
endfunction
" }}}

" ãƒ¢ãƒ¼ãƒ‰ãƒˆã‚°ãƒ« {{{
nmap <silent> [nora:mode]p :<C-u>set paste!<CR>
nmap <silent> [nora:mode]m :<C-u>call ToggleMouse()<CR>
" }}}

" w!!ã§sudoçµŒç”±ã§ä¿å­˜
cmap w!! w !sudo tee > /dev/null %

" }}}

" ã‚¦ã‚¤ãƒ³ãƒ‰ã‚¦æ“ä½œç³» {{{

NeoBundle 'Shougo/neomru.vim'

nmap <silent> [nora]j <C-w>j
nmap <silent> [nora]k <C-w>k
nmap <silent> [nora]l <C-w>l
nmap <silent> [nora]h <C-w>h
nmap <silent> [nora]<C-j> <C-w>j
nmap <silent> [nora]<C-k> <C-w>k
nmap <silent> [nora]<C-l> <C-w>l
nmap <silent> [nora]<C-h> <C-w>h
nnoremap [nora]= <C-w>=
nnoremap [nora]> <C-w>>
nnoremap [nora]< <C-w><
nnoremap [nora]+ <C-w>+
nnoremap [nora]- <C-w>-
let s:bundle = neobundle#get("vim-submode")
function! s:bundle.hooks.on_source(bundle)
    call submode#enter_with('windowi', 'n', '', 's>', '<C-w>>')
    call submode#enter_with('windowi', 'n', '', 's<', '<C-w><')
    call submode#enter_with('windowi', 'n', '', 's+', '<C-w>+')
    call submode#enter_with('windowi', 'n', '', 's-', '<C-w>-')
    call submode#map('windowi', 'n', '', '>', '<C-w>>')
    call submode#map('windowi', 'n', '', '<', '<C-w><')
    call submode#map('windowi', 'n', '', '+', '<C-w>+')
    call submode#map('windowi', 'n', '', '-', '<C-w>-')
endfunction

" ã‚¨ã‚¯ã‚¹ãƒ—ãƒ­ãƒ¼ãƒ©ã‚’é–‹ã
nnoremap <silent> [nora:ext]e :<C-u>VimFilerCreate -split -simple -winwidth=35 -no-quit<CR>
nnoremap <silent> [nora]<C-e> :<C-u>VimFilerBufferDir -split -simple -winwidth=35 -no-quit<CR>

" ã‚¿ã‚°ãƒãƒ¼ã‚’é–‹ã
nnoremap <silent> [nora:ext]t :<C-u>TagbarToggle<CR>
" gundo
nnoremap <silent> [nora:ext]g :<C-u>GundoToggle<CR>


" }}}

" Uniteç³» {{{
nnoremap <silent> [nora]b :<C-u>Unite buffer bookmark<CR>
nnoremap <silent> [nora]o :<C-u>Unite fold outline<CR>
nnoremap <silent> [nora]<C-h> :<C-u>Unite buffer file_mru<CR>
nnoremap <silent> [nora]c :<C-u>UniteWithBufferDir file file/new directory/new<CR>
nnoremap <silent> [nora]q :<C-u>Unite qfixhowm qfixhowm/new <CR>
nnoremap <silent> [nora]<C-q> :<C-u>Unite qfixhowm qfixhowm/new <CR>
nnoremap <silent> [nora]<C-c> :<C-u>UniteWithBufferDir file file/new directory/new<CR>
nnoremap <silent> [nora]y :<C-u>Unite history/yank<CR>

let s:bundle = neobundle#get("unite.vim")
function! s:bundle.hooks.on_source(bundle)
    let g:unite_enable_start_insert=1
    let g:unite_source_history_yank_enable =1
    let g:unite_source_file_mru_limit = 200
endfunction


autocmd NoraAutoCmd FileType unite call s:unite_my_settings()
function! s:unite_my_settings()
    nnoremap <silent> <buffer> <expr> <C-T> unite#do_action('tabopen')
    inoremap <silent> <buffer> <expr> <C-T> unite#do_action('tabopen')
    nnoremap <silent> <buffer> <expr> t unite#do_action('tabopen')
    nnoremap <silent> <buffer> <expr> o unite#do_action('split')
    nnoremap <silent> <buffer> <expr> <C-O> unite#do_action('split')
    inoremap <silent> <buffer> <expr> <C-O> unite#do_action('split')
    nnoremap <silent> <buffer> <expr> <C-V> unite#do_action('vsplit')
    inoremap <silent> <buffer> <expr> <C-V> unite#do_action('vsplit')
    inoremap <silent> <buffer> <expr> <C-V> unite#do_action('vsplit')
    nnoremap <silent> <buffer> <ESC><ESC> :q<CR>
    inoremap <silent> <buffer> <ESC><ESC> <ESC>:q<CR>
    imap <buffer> <C-k>     <Plug>(unite_select_previous_line)
    imap <buffer> <C-j>     <Plug>(unite_select_next_line)
endfunction
" }}}

" ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ“ä½œ(CtrlP) {{{
let s:bundle = neobundle#get("ctrlp.vim")
function! s:bundle.hooks.on_source(bundle)
    let g:ctrlp_map = '<Nop>'
    let g:ctrlp_working_path_mode = 'ra'
    let g:ctrlp_open_new_file = 'r'
    let g:ctrlp_extensions = ['tag', 'quickfix', 'dir', 'line', 'mixed']
    let g:ctrlp_max_files  = 100000 " å¯¾è±¡ãƒ•ã‚¡ã‚¤ãƒ«æœ€å¤§æ•°(default:10000)
    let g:ctrlp_max_depth = 10 " æ¤œç´¢å¯¾è±¡ã®æœ€å¤§éšå±¤æ•°(default:40)
    let g:ctrlp_clear_cache_on_exit = 0 " vimçµ‚äº†æ™‚ã«ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¯ãƒªã‚¢ã—ãªã„(default:1)
    let g:ctrlp_match_window = 'bottom,order:btt,min:1,max:18,results:50' " æ¤œç´¢ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®è¨­å®š
endfunction
nnoremap [nora]m :<C-u>CtrlPMRUFiles<CR> 
" }}}

" HTMLæ“ä½œ {{{
nmap [nora]et <Plug>(endtagcomment)
" }}}

" è¾æ›¸: vim-ref {{{
" vimshell% cd ~/.vim/
" vimshell% curl -sSL "http://jp1.php.net/get/php_manual_ja.tar.gz/from/this/mirror" | tar zxvf -
"
nnoremap [ref] <Nop>
nmap [nora]r [ref]

"Ref webdictã§alcã‚’ä½¿ã†è¨­å®š
let g:ref_source_webdict_cmd = 'lynx -dump -nonumbers %s'
"let g:ref_source_webdict_use_cache = 1
let g:ref_source_webdict_sites = {
            \ 'alc' : {
            \   'url' : 'http://eow.alc.co.jp/%s/UTF-8/',
            \   'cache' : 1
            \   },
            \ 'wiktionary' : {
            \   'url' : 'http://ja.wiktionary.org/wiki/%s',
            \   'keyword_encoding': 'utf-8',
            \   'cache' : 1
            \   }
            \ }
function! g:ref_source_webdict_sites.alc.filter(output)
      return join(split(a:output, "\n")[42 :], "\n")
endfunction

let g:ref_phpmanual_path = "/opt/vim/php-chunked-xhtml/"
nmap [ref]a :<C-u>Ref webdict alc 
nmap [ref]w :<C-u>Ref webdict wiktionary 
nmap [ref]p :<C-u>Ref phpmanual 
" }}}

" ãƒ¡ãƒ¢ {{{

" memolist {{{
let g:memolist_qfixgrep = 1
let g:memolist_memo_suffix = "md"
let g:memolist_memo_date = "%Y-%m-%d %H:%M"
let g:memolist_memo_date = "epoch"
let g:memolist_memo_date = "%d %t"
let g:memolist_prompt_tags = 1
let g:memolist_prompt_categories = 1
let g:memolist_qfixgrep = 1
let g:memolist_vimfiler = 1
let g:memolist_template_dir_path = "~/memo/memolist"
map [nora:ext]ml  :MemoList<cr>
map [nora:ext]mn  :MemoNew<cr>
map [nora:ext]mg  :MemoGrep<cr>
" }}}

" QFixHowm {{{
" ãƒ¡ãƒ¢æ©Ÿèƒ½
"set QFixHowm_Key = '<nop>'
 
let howm_dir             = '~/memo/hown'

" ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³è¨˜æ³•ã‚’ä½¿ã†
"let QFixHowm_FileType = 'markdown'
"let QFixHowm_Title = '#'
"let QFixMRU_Title = {}
"let QFixMRU_Title['mkd']       = '^###[^#]'
"let QFixMRU_Title['mkd_regxp'] = '^###[^#]'
au BufRead,BufNewFile *.md set filetype=markdown

" ãƒ•ã‚¡ã‚¤ãƒ«æ‹¡å¼µå­ã‚’mdã«ã™ã‚‹
let howm_filename = '%Y/%m/%Y-%m-%d-%H%M%S.md'
" ãƒ•ã‚¡ã‚¤ãƒ«ã‚¿ã‚¤ãƒ—ã‚’markdownã«ã™ã‚‹
let QFixHowm_FileType = 'markdown'
" ã‚¿ã‚¤ãƒˆãƒ«è¨˜å·
" let QFixHowm_Title = '#'
" ã‚¿ã‚¤ãƒˆãƒ«è¡Œæ¤œç´¢æ­£è¦è¡¨ç¾ã®è¾æ›¸ã‚’åˆæœŸåŒ–
let QFixMRU_Title = {}
" MRUã§ã‚¿ã‚¤ãƒˆãƒ«è¡Œã¨ã¿ãªã™æ­£è¦è¡¨ç¾(Vimã®æ­£è¦è¡¨ç¾ã§æŒ‡å®š)
let QFixMRU_Title['mkd'] = '^###[^#]'
" grepã§ã‚¿ã‚¤ãƒˆãƒ«è¡Œã¨ã¿ãªã™æ­£è¦è¡¨ç¾(ä½¿ç”¨ã™ã‚‹grepã«ã‚ˆã£ã¦ã¯å¤‰æ›´ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™)
let QFixMRU_Title['mkd_regxp'] = '^###[^#]'
" }}}

" }}}

" Grepç³» {{{
nnoremap <silent> [search] :<C-u>Unite grep:. -buffer-name=search-buffer<CR>
" ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã®å˜èªã§æ¤œç´¢
nnoremap <silent> [search]j :<C-u>Unite grep:. -buffer-name=search-buffer<CR><C-R><C-W><CR>
" æ¤œç´¢ã®å†é–‹
nnoremap <silent> [search]k :<C-u>UniteResume search-buffer<CR>
" }}}

" Gitç³» {{{
nnoremap  [nora:ext]s :<C-u>Git status<CR>
nnoremap  [nora:ext]p :<C-u>Git push<CR>
nnoremap  [nora:ext]a :<C-u>Git add %<CR>
nnoremap  [nora:ext]c :<C-u>Git commit<CR>
nnoremap  [nora:ext]d :<C-u>Git diff %<CR>
" }}}

" Snippet {{{
" ã‚¹ãƒ‹ãƒšãƒƒãƒˆ
NeoBundle 'Shougo/neosnippet'
NeoBundle 'Shougo/neosnippet-snippets'

" Plugin key-mappings.
imap <C-k>     <Plug>(neosnippet_expand_or_jump)
smap <C-k>     <Plug>(neosnippet_expand_or_jump)
xmap <C-k>     <Plug>(neosnippet_expand_target)
 
" SuperTab like snippets behavior.
" imap <expr><TAB> neosnippet#expandable_or_jumpable() ?
" \ "\<Plug>(neosnippet_expand_or_jump)"
" \: pumvisible() ? "\<C-n>" : "\<TAB>"
" smap <expr><TAB> neosnippet#expandable_or_jumpable() ?
" \ "\<Plug>(neosnippet_expand_or_jump)"
" \: "\<TAB>"

let g:neosnippet#snippets_directory='~/.dotfiles/vim/snippets/'
nnoremap [snipet] <nop>
nmap [nora]s [snipet]
nnoremap <silent> [snipet]e :<c-u>NeoSnippetEdit<cr>
nnoremap <silent> [snipet] :<c-u>NeoSnippetEdit<cr>

" For snippet_complete marker.
if has('conceal')
  set conceallevel=2 concealcursor=i
endif

" }}}

" è£œå®Œ {{{
" Luaã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®æœ‰ç„¡ã§ä½¿ç”¨ã™ã‚‹ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚’å¤‰æ›´
function! s:meet_neocomplete_requirements()
	return has('lua') && (v:version > 703 || (v:version == 703 && has('patch885')))
endfunction

if s:meet_neocomplete_requirements()
	NeoBundle 'Shougo/neocomplete.vim'
	NeoBundleFetch 'Shougo/neocomplcache.vim'
else
	NeoBundleFetch 'Shougo/neocomplete.vim'
	NeoBundle 'Shougo/neocomplcache.vim'
endif

if neobundle#is_installed('neocomplete')
	let g:neocomplcate#enable_at_startup=1
endif
if neobundle#is_installed('neocomplcache')
	let g:neocomplcache#enable_at_startup=1
endif

"Note: This option must set it in .vimrc(_vimrc).  NOT IN .gvimrc(_gvimrc)!
" Disable AutoComplPop.
let g:acp_enableAtStartup = 0
" Use neocomplete.
if s:meet_neocomplete_requirements()
	" æ–°ã—ãè¿½åŠ ã—ãŸ neocomplete ã®è¨­å®š
	let g:neocomplete#enable_at_startup = 1
	" Use smartcase.
	let g:neocomplete#enable_smart_case = 1
	" Set minimum syntax keyword length.
	let g:neocomplete#sources#syntax#min_keyword_length = 3
	let g:neocomplete#lock_buffer_name_pattern = '\*ku\*'

	" Define dictionary.
	let g:neocomplete#sources#dictionary#dictionaries = {
		\ 'default' : '',
		\ 'vimshell' : $HOME.'/.vimshell_hist',
		\ 'scheme' : $HOME.'/.gosh_completions'
			\ }

	" Define keyword.
	if !exists('g:neocomplete#keyword_patterns')
		let g:neocomplete#keyword_patterns = {}
	endif
	let g:neocomplete#keyword_patterns['default'] = '\h\w*'

	" Plugin key-mappings.
	inoremap <expr><C-g>     neocomplete#undo_completion()
	inoremap <expr><C-l>     neocomplete#complete_common_string()

	" Recommended key-mappings.
	" <CR>: close popup and save indent.
	inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
	function! s:my_cr_function()
	  return neocomplete#close_popup() . "\<CR>"
	  " For no inserting <CR> key.
	  "return pumvisible() ? neocomplete#close_popup() : "\<CR>"
	endfunction
	" <TAB>: completion.
	inoremap <expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"
	" <C-h>, <BS>: close popup and delete backword char.
	inoremap <expr><C-h> neocomplete#smart_close_popup()."\<C-h>"
	inoremap <expr><BS> neocomplete#smart_close_popup()."\<C-h>"
	inoremap <expr><C-y>  neocomplete#close_popup()
	inoremap <expr><C-e>  neocomplete#cancel_popup()
	" Close popup by <Space>.
	"inoremap <expr><Space> pumvisible() ? neocomplete#close_popup() : "\<Space>"

	" For cursor moving in insert mode(Not recommended)
	"inoremap <expr><Left>  neocomplete#close_popup() . "\<Left>"
	"inoremap <expr><Right> neocomplete#close_popup() . "\<Right>"
	"inoremap <expr><Up>    neocomplete#close_popup() . "\<Up>"
	"inoremap <expr><Down>  neocomplete#close_popup() . "\<Down>"
	" Or set this.
	"let g:neocomplete#enable_cursor_hold_i = 1
	" Or set this.
	"let g:neocomplete#enable_insert_char_pre = 1

	" AutoComplPop like behavior.
	"let g:neocomplete#enable_auto_select = 1

	" Shell like behavior(not recommended).
	"set completeopt+=longest
	"let g:neocomplete#enable_auto_select = 1
	"let g:neocomplete#disable_auto_complete = 1
	"inoremap <expr><TAB>  pumvisible() ? "\<Down>" : "\<C-x>\<C-u>"

	" Enable omni completion.
	autocmd NoraAutoCmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
	autocmd NoraAutoCmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
	autocmd NoraAutoCmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
	autocmd NoraAutoCmd FileType python setlocal omnifunc=pythoncomplete#Complete
	autocmd NoraAutoCmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags

	" Enable heavy omni completion.
	if !exists('g:neocomplete#sources#omni#input_patterns')
	  let g:neocomplete#sources#omni#input_patterns = {}
	endif
	"let g:neocomplete#sources#omni#input_patterns.php = '[^. \t]->\h\w*\|\h\w*::'
	"let g:neocomplete#sources#omni#input_patterns.c = '[^.[:digit:] *\t]\%(\.\|->\)'
	"let g:neocomplete#sources#omni#input_patterns.cpp = '[^.[:digit:] *\t]\%(\.\|->\)\|\h\w*::'

	" For perlomni.vim setting.
	" https://github.com/c9s/perlomni.vim
	let g:neocomplete#sources#omni#input_patterns.perl = '\h\w*->\h\w*\|\h\w*::'
else
	" ä»Šã¾ã§ã® neocomplcache ã®è¨­å®š
endif
" }}}

" Vimshell {{{


":VimShell [{options}...] [{path}]		*:VimShell*
":VimShellCreate [{options}...] [{path}]		*:VimShellCreate*
":VimShellTab [{options}...] [{path}]		*:VimShellTab*
":VimShellPop [{options}...] [{path}]		*:VimShellPop*
":VimShellCurrentDir [{options}...] [{path}]	*:VimShellCurrentDir*
":VimShellBufferDir [{options}...] [{path}]	*:VimShellBufferDir*
".:VimShellExecute [{option}] [{command}]			*:VimShellExecute*
":VimShellInteractive [{option}] [{command}]		*:VimShellInteractive*
":[range]VimShellSendString {string}		*:VimShellSendString*
":VimShellSendBuffer {bufname}			*:VimShellSendBuffer*
":VimShellClose [{buffer-name}]			*:VimShellClose*

" }}}


" }}}

" Hack {{{

" Use vsplit mode
if has("vim_starting") && !has('gui_running') && has('vertsplit')
 function! g:EnableVsplitMode()
   " enable origin mode and left/right margins
   let &t_CS = "y"
   let &t_ti = &t_ti . "\e[?6;69h"
   let &t_te = "\e[?6;69l\e[999H" . &t_te
   let &t_CV = "\e[%i%p1%d;%p2%ds"
   call writefile([ "\e[?6;69h" ], "/dev/tty", "a")
 endfunction

 " old vim does not ignore CPR
 map <special> <Esc>[3;9R <Nop>

 " new vim can't handle CPR with direct mapping
 " map <expr> ^[[3;3R g:EnableVsplitMode()
 set t_F9=[3;3R
 map <expr> <t_F9> g:EnableVsplitMode()
 let &t_RV .= "\e[?6;69h\e[1;3s\e[3;9H\e[6n\e[0;0s\e[?6;69l"
endif

command! -nargs=0 JunkFile call s:open_junk_file()
function! s:open_junk_file()
    let l:junk_dir = $HOME . '/.vim_junk'. strftime('/%Y/%m')
    if !isdirectory(l:junk_dir)
        call mkdir(l:junk_dir, 'p')
    endif

    let l:filename = input('Junk Code: ', l:junk_dir.strftime('/%Y-%m-%d-%H%M%S.'))
    if l:filename != ''
        execute 'edit ' . l:filename
    endif
endfunction

" }}}

" Quickrun {{{

let s:bundle = neobundle#get("vim-quickrun")
let g:quickrun_config = {
\   "_" : {
\       "hook/close_unite_quickfix/enable_hook_loaded" : 1,
\       "hook/unite_quickfix/enable_failure" : 1,
\       "hook/close_quickfix/enable_exit" : 1,
\       "hook/close_buffer/enable_failure" : 1,
\       "hook/close_buffer/enable_empty_data" : 1,
\       "runner" : "vimproc",
\       "runner/vimproc/updatetime" : 60,
\       "outputter" : "multi:buffer:quickfix",
\       "outputter/buffer/split" : ":botright 18sp",
\   },
\}

nnoremap <silent> [nora:ext]r : <C-u>QuickRun<CR>

" }}}

" ãƒã‚ªãƒãƒ³ãƒ‰ãƒ«ç”¨ã®çµ‚äº† {{{
call neobundle#end()
filetype plugin indent on
" }}}
"
" VIMè¨­å®šãƒ•ã‚¡ã‚¤ãƒ«
"
" @Author Hajime <mail@hazime.org>
" @Update 2014.10.10
" @See http://motw.mods.jp/Vim/command.html

nnoremap rv :<C-u>source ~/.vimrc<CR>

" NeoBundleç”¨ã®ã‚¹ã‚¿ãƒ¼ãƒˆã‚¢ãƒƒãƒ— {{{
filetype plugin indent off
if has('vim_starting')
  set runtimepath+=~/.dotfiles/vim/third/neobundle.vim/
endif
" Start Neo Bundle
call neobundle#begin(expand('~/.dotfiles/vim/bundle/'))
" }}}

" Auto Command {{{
function! s:RestoreCursorPostion()
    if line("'\"") <= line("$")
        normal! g`"
        return 1
    endif
endfunction

augroup NoraAutoCmd
  autocmd!
  autocmd BufWinEnter * call s:RestoreCursorPostion()
augroup END

" }}}

" ãƒ—ãƒ¬ãƒ•ã‚£ãƒƒã‚¯ã‚¹ã®è¨­å®š {{{
nmap s <Nop>
nnoremap [nora] <NOP>
nmap s <ESC>[nora]
nmap <C-f> <ESC>[nora]
imap <c-f> <ESC>[nora]

nnoremap [nora:mode] <NOP>
nmap m [nora:mode]

nnoremap [nora:mode]s <esc>[vimshell]

nnoremap [nora:ext] <Nop>
nmap <space> <ESC>[nora:ext]

nnoremap [search] <nop>
nmap [nora]g <esc>[search]
" }}}

" ãƒ™ãƒ¼ã‚·ãƒƒã‚¯ã‚»ãƒƒãƒ†ã‚£ãƒ³ã‚° {{{

" VIã¨ã®äº’æ›æ€§ã‚’ä¿ãŸãªã„
set nocompatible

" ãƒ•ã‚¡ã‚¤ãƒ«ãƒ­ã‚±ãƒ¼ã‚·ãƒ§ãƒ³
set directory=~/.vim.tmp//
set backupdir=~/.vim.tmp//

" Swapã¯ä½¿ã‚ãªã„
set noswapfile
" ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã¯ä½¿ã†
set backup

" VIMã‚³ãƒãƒ³ãƒ‰å±¥æ­´ä¿æŒæ•°
set viminfo='100
" VIMãƒ¬ã‚¸ã‚¹ãƒˆãƒªä¿æŒæ•°
set viminfo+="1000
" VIMINFOä¿å­˜ãƒ•ã‚¡ã‚¤ãƒ«
set viminfo+=n~/.vim.info

"
" åŒæ™‚ç·¨é›†ãŒç™ºç”Ÿã—ãŸæ™‚ã®æŒ™å‹•
"

" ä»–ã®å ´æ‰€ã§æ›´æ–°ã•ã‚ŒãŸã‚‰è‡ªå‹•çš„ã«èª­ã¿è¾¼ã‚€
set autoread

" ãƒãƒƒã‚¯ã‚¹ãƒšãƒ¼ã‚¹ã§å‰Šé™¤å¯èƒ½ãªã‚‚ã®ã‚’å¢—ã‚„ã™
set backspace=start,eol,indent


"
" æ¤œç´¢ã®æŒ™å‹•
"

" æ¤œç´¢æ™‚ã«å¤§æ–‡å­—å°æ–‡å­—ã‚’ç„¡è¦–
set ignorecase

" ãŸã ã—ã€æ¤œç´¢æ–‡å­—ã«å¤§æ–‡å­—å°æ–‡å­—ãŒã‚ã‚Œã°ç„¡è¦–ã—ãªã„
set smartcase  " do not ignore capital when search words includs both

" æ¤œç´¢æ–‡å­—ã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆã—ãªã„
set nohlsearch

"
" TTYã®è¨­å®š
"
set lazyredraw
set ttyfast

" ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦å¹…ã§æŠ˜ã‚Šè¿”ã™
set nowrap

" å›ºå®šæŠ˜ã‚Šè¿”ã—æ–‡å­—å¹…ã‚’æŒãŸãªã„
set textwidth=0

" è¡Œç•ªå·ã‚’è¡¨ç¤ºã™ã‚‹
set number

set scrolloff=16

" }}}

" æŠ˜ã‚ŠãŸãŸã¿ {{{
"set foldtext=FoldCCtext()
set foldcolumn=3
set fillchars=vert:\|
hi Folded gui=bold term=standout ctermbg=LightGrey ctermfg=DarkBlue guibg=Grey30 guifg=Grey80
hi FoldColumn gui=bold term=standout ctermbg=LightGrey ctermfg=DarkBlue guibg=Grey guifg=DarkBlue

" }}}

" ã‚¿ãƒ–ç³»ã®è¨­å®š {{{
set tabstop=4
set softtabstop=4
set shiftwidth=4
set expandtab
" }}}

" ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒ©ã‚¤ãƒ³ã®è¨­å®š {{{
set laststatus=2
"set showmode
set noshowmode
set showcmd
set wildmenu
set ruler

NeoBundle 'itchyny/lightline.vim'
" wonbat solarized landscape
let g:lightline = {
      \ 'colorscheme': 'jellybeans',
      \ 'component': {
      \   'readonly': '%{&readonly?"î‚¢":""}',
      \ },
      \ 'separator': { 'left': 'î‚°', 'right': 'î‚²' },
      \ 'subseparator': { 'left': 'î‚±', 'right': 'î‚³' }
      \ }
 
let g:lightline = {
      \ 'colorscheme': 'jellybeans',
      \ 'active': {
      \   'left': [ [ 'mode', 'paste' ], [ 'fugitive', 'filename' ], ['ctrlpmark'] ],
      \   'right': [ [ 'syntastic', 'lineinfo' ], ['percent'], [ 'fileformat', 'fileencoding', 'filetype' ] ]
      \ },
      \ 'component': {
      \   'readonly': '%{&readonly?"î‚¢":""}',
      \ },
      \ 'component_function': {
      \   'fugitive': 'MyFugitive',
      \   'filename': 'MyFilename',
      \   'fileformat': 'MyFileformat',
      \   'filetype': 'MyFiletype',
      \   'fileencoding': 'MyFileencoding',
      \   'mode': 'MyMode',
      \   'ctrlpmark': 'CtrlPMark',
      \ },
      \ 'component_expand': {
      \   'syntastic': 'SyntasticStatuslineFlag',
      \ },
      \ 'component_type': {
      \   'syntastic': 'error',
      \ },
      \ 'separator': { 'left': 'î‚°', 'right': 'î‚²' },
      \ 'subseparator': { 'left': 'î‚±', 'right': 'î‚³' }
      \ }

function! MyModified()
  return &ft =~ 'help' ? '' : &modified ? '+' : &modifiable ? '' : '-'
endfunction

function! MyReadonly()
  return &ft !~? 'help' && &readonly ? 'RO' : ''
endfunction

function! MyFilename()
  let fname = expand('%:t')
  return fname == 'ControlP' ? g:lightline.ctrlp_item :
        \ fname == '__Tagbar__' ? g:lightline.fname :
        \ fname =~ '__Gundo\|NERD_tree' ? '' :
        \ &ft == 'vimfiler' ? vimfiler#get_status_string() :
        \ &ft == 'unite' ? unite#get_status_string() :
        \ &ft == 'vimshell' ? vimshell#get_status_string() :
        \ ('' != MyReadonly() ? MyReadonly() . ' ' : '') .
        \ ('' != fname ? fname : '[No Name]') .
        \ ('' != MyModified() ? ' ' . MyModified() : '')
endfunction

function! MyFugitive()
  try
    if expand('%:t') !~? 'Tagbar\|Gundo\|NERD' && &ft !~? 'vimfiler' && exists('*fugitive#head')
      let mark = ''  " edit here for cool mark
      let _ = fugitive#head()
      return strlen(_) ? mark._ : ''
    endif
  catch
  endtry
  return ''
endfunction

function! MyFileformat()
  return winwidth(0) > 70 ? &fileformat : ''
endfunction

function! MyFiletype()
  return winwidth(0) > 70 ? (strlen(&filetype) ? &filetype : 'no ft') : ''
endfunction

function! MyFileencoding()
  return winwidth(0) > 70 ? (strlen(&fenc) ? &fenc : &enc) : ''
endfunction

function! MyMode()
  let fname = expand('%:t')
  return fname == '__Tagbar__' ? 'Tagbar' :
        \ fname == 'ControlP' ? 'CtrlP' :
        \ fname == '__Gundo__' ? 'Gundo' :
        \ fname == '__Gundo_Preview__' ? 'Gundo Preview' :
        \ fname =~ 'NERD_tree' ? 'NERDTree' :
        \ &ft == 'unite' ? 'Unite' :
        \ &ft == 'vimfiler' ? 'VimFiler' :
        \ &ft == 'vimshell' ? 'VimShell' :
        \ winwidth(0) > 60 ? lightline#mode() : ''
endfunction

function! CtrlPMark()
  if expand('%:t') =~ 'ControlP'
    call lightline#link('iR'[g:lightline.ctrlp_regex])
    return lightline#concatenate([g:lightline.ctrlp_prev, g:lightline.ctrlp_item
          \ , g:lightline.ctrlp_next], 0)
  else
    return ''
  endif
endfunction

let g:ctrlp_status_func = {
  \ 'main': 'CtrlPStatusFunc_1',
  \ 'prog': 'CtrlPStatusFunc_2',
  \ }

function! CtrlPStatusFunc_1(focus, byfname, regex, prev, item, next, marked)
  let g:lightline.ctrlp_regex = a:regex
  let g:lightline.ctrlp_prev = a:prev
  let g:lightline.ctrlp_item = a:item
  let g:lightline.ctrlp_next = a:next
  return lightline#statusline(0)
endfunction

function! CtrlPStatusFunc_2(str)
  return lightline#statusline(0)
endfunction

let g:tagbar_status_func = 'TagbarStatusFunc'

function! TagbarStatusFunc(current, sort, fname, ...) abort
    let g:lightline.fname = a:fname
  return lightline#statusline(0)
endfunction

augroup AutoSyntastic
  autocmd!
  autocmd BufWritePost *.c,*.cpp call s:syntastic()
augroup END
function! s:syntastic()
  SyntasticCheck
  call lightline#update()
endfunction

let g:unite_force_overwrite_statusline = 0
let g:vimfiler_force_overwrite_statusline = 0
let g:vimshell_force_overwrite_statusline = 0

" set statusline=%<     " è¡ŒãŒé•·ã™ãã‚‹ã¨ãã«åˆ‡ã‚Šè©°ã‚ã‚‹ä½ç½®
" set statusline+=[%n]  " ãƒãƒƒãƒ•ã‚¡ç•ªå·
" set statusline+=%m    " %m ä¿®æ­£ãƒ•ãƒ©ã‚°
" set statusline+=%r    " %r èª­ã¿è¾¼ã¿å°‚ç”¨ãƒ•ãƒ©ã‚°
" set statusline+=%h    " %h ãƒ˜ãƒ«ãƒ—ãƒãƒƒãƒ•ã‚¡ãƒ•ãƒ©ã‚°
" set statusline+=%w    " %w ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒ•ãƒ©ã‚°
" set statusline+=%{'['.(&fenc!=''?&fenc:&enc).':'.&ff.']'}  " fencã¨ffã‚’è¡¨ç¤º
" set statusline+=%y    " ãƒãƒƒãƒ•ã‚¡å†…ã®ãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚¿ã‚¤ãƒ—
" set statusline+=\     " ç©ºç™½ã‚¹ãƒšãƒ¼ã‚¹
" if winwidth(0) >= 130
"     set statusline+=%F    " ãƒãƒƒãƒ•ã‚¡å†…ã®ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ•ãƒ«ãƒ‘ã‚¹
" else
"     set statusline+=%t    " ãƒ•ã‚¡ã‚¤ãƒ«åã®ã¿
" endif
" set statusline+=%=    " å·¦å¯„ã›é …ç›®ã¨å³å¯„ã›é …ç›®ã®åŒºåˆ‡ã‚Š
" set statusline+=%{fugitive#statusline()}  " Gitã®ãƒ–ãƒ©ãƒ³ãƒåã‚’è¡¨ç¤º
" set statusline+=\ \   " ç©ºç™½ã‚¹ãƒšãƒ¼ã‚¹2å€‹
" set statusline+=%1l   " ä½•è¡Œç›®ã«ã‚«ãƒ¼ã‚½ãƒ«ãŒã‚ã‚‹ã‹
" set statusline+=/
" set statusline+=%L    " ãƒãƒƒãƒ•ã‚¡å†…ã®ç·è¡Œæ•°
" set statusline+=,
" set statusline+=%c    " ä½•åˆ—ç›®ã«ã‚«ãƒ¼ã‚½ãƒ«ãŒã‚ã‚‹ã‹
" set statusline+=%V    " ç”»é¢ä¸Šã®ä½•åˆ—ç›®ã«ã‚«ãƒ¼ã‚½ãƒ«ãŒã‚ã‚‹ã‹
" set statusline+=\ \   " ç©ºç™½ã‚¹ãƒšãƒ¼ã‚¹2å€‹
" set statusline+=%P    " ãƒ•ã‚¡ã‚¤ãƒ«å†…ã®ä½•ï¼…ã®ä½ç½®ã«ã‚ã‚‹ã‹

" }}}

" æ—¥æœ¬èªé–¢é€£ {{{

" æ–‡å­—ã‚³ãƒ¼ãƒ‰åˆ¤å®šé †åº
set fileencodings=utf-8,euc-jp,iso-2022-jp,cp932

" }}}

" ã‚·ãƒ³ã‚¿ãƒƒã‚¯ã‚¹ {{{
syntax enable
" }}}

" NeoBundle {{{
NeoBundleFetch 'Shougo/neobundle.vim'

" Vim Procã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
NeoBundle 'Shougo/vimproc',{'build': 
\ {
\   'windows': 'make -f make_windows.mak',
\   'cygwin': 'make -f make_cygwin.mak',
\   'mac': 'make -f make_mac.mak',
\   'unix': 'make -f make_unix.mak',
\ }
\}

NeoBundleLazy 'thinca/vim-quickrun', {
            \ 'autoload' : {
            \     'commands' : [ 'QuickRun' ]
            \  }
            \}

NeoBundleLazy 'Shougo/vimfiler.vim', {
\   'autoload' : { 'commands' : [ 'VimFiler', 'VimFilerTab', 'VimFilerExplorer', 'VimFilerBufferDir', 'VimFilerCreate' ] },
\   'depends': [ 'Shougo/unite.vim' ],
\ }

NeoBundleLazy 'Shougo/unite.vim' , {
\   'autoload' : { 'commands' : [ 'Unite' ] }
\ }

" VimShell
NeoBundleLazy 'Shougo/vimshell', {'depends': ['Shougo/vimproc']}


" Uniteãƒ—ãƒ©ã‚°ã‚¤ãƒ³
NeoBundleLazy 'Shougo/unite-outline'
" NeoBundleLazy 'ujihisa/unite-colorscheme'
NeoBundleLazy 'tacroe/unite-mark'
NeoBundleLazy 'osyo-manga/unite-fold'
" NeoBundleLazy 'taka84u9/unite-git'
" NeoBundleLazy 'thinca/vim-unite-history'
" NeoBundleLazy 'kannokanno/unite-dwm'
NeoBundleLazy 'tsukkee/unite-tag'


NeoBundleLazy 'thinca/vim-ref', {
\ 'autoload' : {'commands': [ 'Ref' ] },
\ 'depends' : ["mfumi/ref-dicts-en"]
\}
NeoBundleLazy 'mfumi/ref-dicts-en'

"
" ãƒ¡ãƒ¢å¸³
"
" @See https://sites.google.com/site/fudist/Home/qfixhowm/install
NeoBundleLazy 'fuenor/qfixgrep'
NeoBundleLazy 'fuenor/qfixhowm'
NeoBundleLazy "osyo-manga/unite-qfixhowm"


NeoBundleLazy "sjl/gundo.vim", {"autoload": {"commands": ['GundoToggle'],}}
NeoBundleLazy 'majutsushi/tagbar', {"autload": {"commands": ["TagbarToggle"],}}

NeoBundleLazy 'plasticboy/vim-markdown', {"autoload": {"filetypes": ["markdown"]}}

" ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆã‚’ã‚ã‹ã‚Šã‚„ã™ãã™ã‚‹
NeoBundleLazy  'nathanaelkane/vim-indent-guides'

" VimTemplate
NeoBundleLazy "thinca/vim-template"


" ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªå˜ä½ã§ã®vimrcã‚’æœ‰åŠ¹ã«ã™ã‚‹
NeoBundleLazy 'thinca/vim-localrc'

" ctagsã‚’è‡ªå‹•åŒ–
NeoBundleLazy 'soramugi/auto-ctags.vim'

"
" ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ç”¨
"
" HTML5ã‚·ãƒ³ã‚¿ãƒƒã‚¯ã‚¹ã‚’æœ‰åŠ¹ã«ã™ã‚‹
NeoBundleLazy 'othree/html5.vim.git', {"autoload": {"filetypes": ['html']}}

" CoffeeScriptç”¨ãƒ—ãƒ©ã‚°ã‚¤ãƒ³
NeoBundleLazy 'kchmck/vim-coffee-script', {"autoload": {"filetype": ["coffee"]}}

" Align
NeoBundleLazy 'h1mesuke/vim-alignta.git', {"autoload": {"commands": ["Align"]}}

" TagList
NeoBundleLazy 'taglist.vim'

" ã‚¿ã‚°ã‚¸ãƒ£ãƒ³ãƒ—
NeoBundleLazy  'szw/vim-tags'

"Dockerfile Syntax
NeoBundleLazy 'ekalinin/Dockerfile.vim', {"autoload": {"filetype": ["dockerfile"]}}

"Vagrant Syntax
NeoBundleLazy 'markcornick/vim-vagrant', {"autoload": {"filetype": ["vagrantfile"]}}

"Tmux Syntax
NeoBundleLazy 'Keithbsmiley/tmux.vim', {"autoload": {"filetype": ["tmux"]}}

" Powerline
NeoBundleLazy 'Lokaltog/powerline', { 'rtp' : 'powerline/bindings/vim' }
NeoBundleLazy 'Lokaltog/powerline-fontpatcher'

" HTMLé–‰ã˜ã‚¿ã‚°å¾Œã®ã‚³ãƒ¡ãƒ³ãƒˆã‚’,tã§å…¥åŠ›
NeoBundleLazy 'haya14busa/endtagcomment.vim', {"autoload": {"filetype": ["html"]}}

" ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆç®¡ç†
" NeoBundle 'project.vim'
NeoBundleLazy 'kien/ctrlp.vim', {"autoload": {"commands": ["CtrlP", "CtrlPMRUFiles"]}}

" ãƒ¡ãƒ¢
NeoBundleLazy 'glidenote/memolist.vim', {"autoload": {"commands": ["MemoList"]}}

" }}}

" è¨­å®š {{{
NeoBundle 'kana/vim-textobj-user'

" Submoduleã‚’æœ‰åŠ¹ã«ã™ã‚‹
NeoBundle  'kana/vim-submode'

" Gitã‚’ä¾¿åˆ©ã«ä½¿ã†
NeoBundle 'tpope/vim-fugitive'

" ã‚³ãƒ¡ãƒ³ãƒˆON/OFFã‚’æ‰‹è»½ã«å®Ÿè¡Œ (gcc)
NeoBundle 'tomtom/tcomment_vim'

" Tabå˜ä½ã§ã®cdã‚’æœ‰åŠ¹ã«ã™ã‚‹
NeoBundle 'kana/vim-tabpagecd'

" ã‚«ãƒ©ãƒ¼ã‚¹ã‚­ãƒ¼ãƒ
NeoBundle 'nanotech/jellybeans.vim'
let s:bundle = neobundle#get('jellybeans.vim')
function! s:bundle.hooks.on_source(bundle)
    colorscheme jellybeans
endfunction

" Undoã‚’ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‰ã˜ãŸå¾Œã‚‚æœ‰åŠ¹ã«ã™ã‚‹
if has('persistent_undo')
    set undofile
    set undodir=$HOME/.vim.tmp
endif 

" ã‚­ãƒ¼ãƒã‚¤ãƒ³ãƒ‰ {{{

" é–“é•ãˆãã†ãªãƒã‚¤ãƒ³ãƒ‰ã‚’èª¿æ•´(äº‹æ•…ã®ç´ ) {{{
nnoremap ZZ <Nop>
nnoremap ZQ <Nop>
nnoremap Q <Nop>
inoremap <F1> <ESC>
nnoremap <F1> <ESC>
vnoremap <F1> <ESC>
nnoremap ; :
cmap w1 w! 
cmap q1 q! 
" }}}

" VIã‚’ã‚‚ã£ã¨ç›´æ„Ÿçš„ã«ã™ã‚‹ {{{
nnoremap j gj
nnoremap k gk
nnoremap gj j
nnoremap gk k
inoremap jj <ESC>

" ã‚«ãƒ¼ã‚½ãƒ«ä¸‹ã®å˜èªã‚’ * ã§æ¤œç´¢
vnoremap <silent> * "vy/\V<C-r>=substitute(escape(@v, '\/'), "\n", '\\n', 'g')<CR><CR>

" æ¤œç´¢å¾Œã«ã‚¸ãƒ£ãƒ³ãƒ—ã—ãŸéš›ã«æ¤œç´¢å˜èªã‚’ç”»é¢ä¸­å¤®ã«æŒã£ã¦ãã‚‹
nnoremap n nzz
nnoremap N Nzz
nnoremap * *zz
nnoremap # #zz
nnoremap g* g*zz
nnoremap g# g#zz

" vã‚’äºŒå›ã§è¡Œæœ«ã¾ã§é¸æŠ
vnoremap v $h

set showmatch           " å¯¾å¿œã™ã‚‹æ‹¬å¼§ãªã©ã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆè¡¨ç¤ºã™ã‚‹
set matchtime=3         " å¯¾å¿œæ‹¬å¼§ã®ãƒã‚¤ãƒ©ã‚¤ãƒˆè¡¨ç¤ºã‚’3ç§’ã«ã™ã‚‹
" å¯¾å¿œæ‹¬å¼§ã«'<'ã¨'>'ã®ãƒšã‚¢ã‚’è¿½åŠ 
set matchpairs& matchpairs+=<:>
" ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆä¸å¯è¦–æ–‡å­—ã¯ç¾ã—ããªã„ã®ã§Unicodeã§ç¶ºéº—ã«
set listchars=tab:Â»-,trail:-,extends:Â»,precedes:Â«,nbsp:%,eol:â†²
" }}}

" ãƒã‚¦ã‚¹ã®è¨­å®š {{{

" ãƒã‚¦ã‚¹ã®æœ‰åŠ¹ç„¡åŠ¹
nnoremap <F3> :call ToggleMouse()<CR>
inoremap <F3> :call ToggleMouse()<CR>
function! ToggleMouse()
	if &mouse == 'a'
		set mouse =
		echo "Mouse usage disabled"
	else
		set mouse=a
		echo "Mouse usage enabled"
	endif
endfunction
" }}}

" ãƒ¢ãƒ¼ãƒ‰ãƒˆã‚°ãƒ« {{{
nmap <silent> [nora:mode]p :<C-u>set paste!<CR>
nmap <silent> [nora:mode]m :<C-u>call ToggleMouse()<CR>
" }}}

" w!!ã§sudoçµŒç”±ã§ä¿å­˜
cmap w!! w !sudo tee > /dev/null %

" }}}

" ã‚¦ã‚¤ãƒ³ãƒ‰ã‚¦æ“ä½œç³» {{{

NeoBundle 'Shougo/neomru.vim'

nmap <silent> [nora]j <C-w>j
nmap <silent> [nora]k <C-w>k
nmap <silent> [nora]l <C-w>l
nmap <silent> [nora]h <C-w>h
nmap <silent> [nora]<C-j> <C-w>j
nmap <silent> [nora]<C-k> <C-w>k
nmap <silent> [nora]<C-l> <C-w>l
nmap <silent> [nora]<C-h> <C-w>h
nnoremap [nora]= <C-w>=
nnoremap [nora]> <C-w>>
nnoremap [nora]< <C-w><
nnoremap [nora]+ <C-w>+
nnoremap [nora]- <C-w>-
let s:bundle = neobundle#get("vim-submode")
function! s:bundle.hooks.on_source(bundle)
    call submode#enter_with('windowi', 'n', '', 's>', '<C-w>>')
    call submode#enter_with('windowi', 'n', '', 's<', '<C-w><')
    call submode#enter_with('windowi', 'n', '', 's+', '<C-w>+')
    call submode#enter_with('windowi', 'n', '', 's-', '<C-w>-')
    call submode#map('windowi', 'n', '', '>', '<C-w>>')
    call submode#map('windowi', 'n', '', '<', '<C-w><')
    call submode#map('windowi', 'n', '', '+', '<C-w>+')
    call submode#map('windowi', 'n', '', '-', '<C-w>-')
endfunction

" ã‚¨ã‚¯ã‚¹ãƒ—ãƒ­ãƒ¼ãƒ©ã‚’é–‹ã
nnoremap <silent> [nora:ext]e :<C-u>VimFilerCreate -split -simple -winwidth=35 -no-quit<CR>
nnoremap <silent> [nora]<C-e> :<C-u>VimFilerBufferDir -split -simple -winwidth=35 -no-quit<CR>

" ã‚¿ã‚°ãƒãƒ¼ã‚’é–‹ã
nnoremap <silent> [nora:ext]t :<C-u>TagbarToggle<CR>
" gundo
nnoremap <silent> [nora:ext]g :<C-u>GundoToggle<CR>


" }}}

" Uniteç³» {{{
nnoremap <silent> [nora]b :<C-u>Unite buffer bookmark<CR>
nnoremap <silent> [nora]o :<C-u>Unite fold outline<CR>
nnoremap <silent> [nora]<C-h> :<C-u>Unite buffer file_mru<CR>
nnoremap <silent> [nora]c :<C-u>UniteWithBufferDir file file/new directory/new<CR>
nnoremap <silent> [nora]q :<C-u>Unite qfixhowm qfixhowm/new <CR>
nnoremap <silent> [nora]<C-q> :<C-u>Unite qfixhowm qfixhowm/new <CR>
nnoremap <silent> [nora]<C-c> :<C-u>UniteWithBufferDir file file/new directory/new<CR>
nnoremap <silent> [nora]y :<C-u>Unite history/yank<CR>

let s:bundle = neobundle#get("unite.vim")
function! s:bundle.hooks.on_source(bundle)
    let g:unite_enable_start_insert=1
    let g:unite_source_history_yank_enable =1
    let g:unite_source_file_mru_limit = 200
endfunction


autocmd NoraAutoCmd FileType unite call s:unite_my_settings()
function! s:unite_my_settings()
    nnoremap <silent> <buffer> <expr> <C-T> unite#do_action('tabopen')
    inoremap <silent> <buffer> <expr> <C-T> unite#do_action('tabopen')
    nnoremap <silent> <buffer> <expr> t unite#do_action('tabopen')
    nnoremap <silent> <buffer> <expr> o unite#do_action('split')
    nnoremap <silent> <buffer> <expr> <C-O> unite#do_action('split')
    inoremap <silent> <buffer> <expr> <C-O> unite#do_action('split')
    nnoremap <silent> <buffer> <expr> <C-V> unite#do_action('vsplit')
    inoremap <silent> <buffer> <expr> <C-V> unite#do_action('vsplit')
    inoremap <silent> <buffer> <expr> <C-V> unite#do_action('vsplit')
    nnoremap <silent> <buffer> <ESC><ESC> :q<CR>
    inoremap <silent> <buffer> <ESC><ESC> <ESC>:q<CR>
    imap <buffer> <C-k>     <Plug>(unite_select_previous_line)
    imap <buffer> <C-j>     <Plug>(unite_select_next_line)
endfunction
" }}}

" ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ“ä½œ(CtrlP) {{{
let s:bundle = neobundle#get("ctrlp.vim")
function! s:bundle.hooks.on_source(bundle)
    let g:ctrlp_map = '<Nop>'
    let g:ctrlp_working_path_mode = 'ra'
    let g:ctrlp_open_new_file = 'r'
    let g:ctrlp_extensions = ['tag', 'quickfix', 'dir', 'line', 'mixed']
    let g:ctrlp_max_files  = 100000 " å¯¾è±¡ãƒ•ã‚¡ã‚¤ãƒ«æœ€å¤§æ•°(default:10000)
    let g:ctrlp_max_depth = 10 " æ¤œç´¢å¯¾è±¡ã®æœ€å¤§éšå±¤æ•°(default:40)
    let g:ctrlp_clear_cache_on_exit = 0 " vimçµ‚äº†æ™‚ã«ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¯ãƒªã‚¢ã—ãªã„(default:1)
    let g:ctrlp_match_window = 'bottom,order:btt,min:1,max:18,results:50' " æ¤œç´¢ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®è¨­å®š
endfunction
nnoremap [nora]m :<C-u>CtrlPMRUFiles<CR> 
" }}}

" HTMLæ“ä½œ {{{
nmap [nora]et <Plug>(endtagcomment)
" }}}

" è¾æ›¸: vim-ref {{{
" vimshell% cd ~/.vim/
" vimshell% curl -sSL "http://jp1.php.net/get/php_manual_ja.tar.gz/from/this/mirror" | tar zxvf -
"
nnoremap [ref] <Nop>
nmap [nora]r [ref]

"Ref webdictã§alcã‚’ä½¿ã†è¨­å®š
let g:ref_source_webdict_cmd = 'lynx -dump -nonumbers %s'
"let g:ref_source_webdict_use_cache = 1
let g:ref_source_webdict_sites = {
            \ 'alc' : {
            \   'url' : 'http://eow.alc.co.jp/%s/UTF-8/',
            \   'cache' : 1
            \   },
            \ 'wiktionary' : {
            \   'url' : 'http://ja.wiktionary.org/wiki/%s',
            \   'keyword_encoding': 'utf-8',
            \   'cache' : 1
            \   }
            \ }
function! g:ref_source_webdict_sites.alc.filter(output)
      return join(split(a:output, "\n")[42 :], "\n")
endfunction

let g:ref_phpmanual_path = "/opt/vim/php-chunked-xhtml/"
nmap [ref]a :<C-u>Ref webdict alc 
nmap [ref]w :<C-u>Ref webdict wiktionary 
nmap [ref]p :<C-u>Ref phpmanual 
" }}}

" ãƒ¡ãƒ¢ {{{

" memolist {{{
let g:memolist_qfixgrep = 1
let g:memolist_memo_suffix = "md"
let g:memolist_memo_date = "%Y-%m-%d %H:%M"
let g:memolist_memo_date = "epoch"
let g:memolist_memo_date = "%d %t"
let g:memolist_prompt_tags = 1
let g:memolist_prompt_categories = 1
let g:memolist_qfixgrep = 1
let g:memolist_vimfiler = 1
let g:memolist_template_dir_path = "~/memo/memolist"
map [nora:ext]ml  :MemoList<cr>
map [nora:ext]mn  :MemoNew<cr>
map [nora:ext]mg  :MemoGrep<cr>
" }}}

" QFixHowm {{{
" ãƒ¡ãƒ¢æ©Ÿèƒ½
"set QFixHowm_Key = '<nop>'
 
let howm_dir             = '~/memo/hown'

" ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³è¨˜æ³•ã‚’ä½¿ã†
"let QFixHowm_FileType = 'markdown'
"let QFixHowm_Title = '#'
"let QFixMRU_Title = {}
"let QFixMRU_Title['mkd']       = '^###[^#]'
"let QFixMRU_Title['mkd_regxp'] = '^###[^#]'
au BufRead,BufNewFile *.md set filetype=markdown

" ãƒ•ã‚¡ã‚¤ãƒ«æ‹¡å¼µå­ã‚’mdã«ã™ã‚‹
let howm_filename = '%Y/%m/%Y-%m-%d-%H%M%S.md'
" ãƒ•ã‚¡ã‚¤ãƒ«ã‚¿ã‚¤ãƒ—ã‚’markdownã«ã™ã‚‹
let QFixHowm_FileType = 'markdown'
" ã‚¿ã‚¤ãƒˆãƒ«è¨˜å·
" let QFixHowm_Title = '#'
" ã‚¿ã‚¤ãƒˆãƒ«è¡Œæ¤œç´¢æ­£è¦è¡¨ç¾ã®è¾æ›¸ã‚’åˆæœŸåŒ–
let QFixMRU_Title = {}
" MRUã§ã‚¿ã‚¤ãƒˆãƒ«è¡Œã¨ã¿ãªã™æ­£è¦è¡¨ç¾(Vimã®æ­£è¦è¡¨ç¾ã§æŒ‡å®š)
let QFixMRU_Title['mkd'] = '^###[^#]'
" grepã§ã‚¿ã‚¤ãƒˆãƒ«è¡Œã¨ã¿ãªã™æ­£è¦è¡¨ç¾(ä½¿ç”¨ã™ã‚‹grepã«ã‚ˆã£ã¦ã¯å¤‰æ›´ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™)
let QFixMRU_Title['mkd_regxp'] = '^###[^#]'
" }}}

" }}}

" Grepç³» {{{
nnoremap <silent> [search] :<C-u>Unite grep:. -buffer-name=search-buffer<CR>
" ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã®å˜èªã§æ¤œç´¢
nnoremap <silent> [search]j :<C-u>Unite grep:. -buffer-name=search-buffer<CR><C-R><C-W><CR>
" æ¤œç´¢ã®å†é–‹
nnoremap <silent> [search]k :<C-u>UniteResume search-buffer<CR>
" }}}

" Gitç³» {{{
nnoremap  [nora:ext]s :<C-u>Git status<CR>
nnoremap  [nora:ext]p :<C-u>Git push<CR>
nnoremap  [nora:ext]a :<C-u>Git add %<CR>
nnoremap  [nora:ext]c :<C-u>Git commit<CR>
nnoremap  [nora:ext]d :<C-u>Git diff %<CR>
" }}}

" Snippet {{{
" ã‚¹ãƒ‹ãƒšãƒƒãƒˆ
NeoBundle 'Shougo/neosnippet'
NeoBundle 'Shougo/neosnippet-snippets'

" Plugin key-mappings.
imap <C-k>     <Plug>(neosnippet_expand_or_jump)
smap <C-k>     <Plug>(neosnippet_expand_or_jump)
xmap <C-k>     <Plug>(neosnippet_expand_target)
 
" SuperTab like snippets behavior.
" imap <expr><TAB> neosnippet#expandable_or_jumpable() ?
" \ "\<Plug>(neosnippet_expand_or_jump)"
" \: pumvisible() ? "\<C-n>" : "\<TAB>"
" smap <expr><TAB> neosnippet#expandable_or_jumpable() ?
" \ "\<Plug>(neosnippet_expand_or_jump)"
" \: "\<TAB>"

let g:neosnippet#snippets_directory='~/.dotfiles/vim/snippets/'
nnoremap [snipet] <nop>
nmap [nora]s [snipet]
nnoremap <silent> [snipet]e :<c-u>NeoSnippetEdit<cr>
nnoremap <silent> [snipet] :<c-u>NeoSnippetEdit<cr>

" For snippet_complete marker.
if has('conceal')
  set conceallevel=2 concealcursor=i
endif

" }}}

" è£œå®Œ {{{
" Luaã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®æœ‰ç„¡ã§ä½¿ç”¨ã™ã‚‹ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚’å¤‰æ›´
function! s:meet_neocomplete_requirements()
	return has('lua') && (v:version > 703 || (v:version == 703 && has('patch885')))
endfunction

if s:meet_neocomplete_requirements()
	NeoBundle 'Shougo/neocomplete.vim'
	NeoBundleFetch 'Shougo/neocomplcache.vim'
else
	NeoBundleFetch 'Shougo/neocomplete.vim'
	NeoBundle 'Shougo/neocomplcache.vim'
endif

if neobundle#is_installed('neocomplete')
	let g:neocomplcate#enable_at_startup=1
endif
if neobundle#is_installed('neocomplcache')
	let g:neocomplcache#enable_at_startup=1
endif

"Note: This option must set it in .vimrc(_vimrc).  NOT IN .gvimrc(_gvimrc)!
" Disable AutoComplPop.
let g:acp_enableAtStartup = 0
" Use neocomplete.
if s:meet_neocomplete_requirements()
	" æ–°ã—ãè¿½åŠ ã—ãŸ neocomplete ã®è¨­å®š
	let g:neocomplete#enable_at_startup = 1
	" Use smartcase.
	let g:neocomplete#enable_smart_case = 1
	" Set minimum syntax keyword length.
	let g:neocomplete#sources#syntax#min_keyword_length = 3
	let g:neocomplete#lock_buffer_name_pattern = '\*ku\*'

	" Define dictionary.
	let g:neocomplete#sources#dictionary#dictionaries = {
		\ 'default' : '',
		\ 'vimshell' : $HOME.'/.vimshell_hist',
		\ 'scheme' : $HOME.'/.gosh_completions'
			\ }

	" Define keyword.
	if !exists('g:neocomplete#keyword_patterns')
		let g:neocomplete#keyword_patterns = {}
	endif
	let g:neocomplete#keyword_patterns['default'] = '\h\w*'

	" Plugin key-mappings.
	inoremap <expr><C-g>     neocomplete#undo_completion()
	inoremap <expr><C-l>     neocomplete#complete_common_string()

	" Recommended key-mappings.
	" <CR>: close popup and save indent.
	inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
	function! s:my_cr_function()
	  return neocomplete#close_popup() . "\<CR>"
	  " For no inserting <CR> key.
	  "return pumvisible() ? neocomplete#close_popup() : "\<CR>"
	endfunction
	" <TAB>: completion.
	inoremap <expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"
	" <C-h>, <BS>: close popup and delete backword char.
	inoremap <expr><C-h> neocomplete#smart_close_popup()."\<C-h>"
	inoremap <expr><BS> neocomplete#smart_close_popup()."\<C-h>"
	inoremap <expr><C-y>  neocomplete#close_popup()
	inoremap <expr><C-e>  neocomplete#cancel_popup()
	" Close popup by <Space>.
	"inoremap <expr><Space> pumvisible() ? neocomplete#close_popup() : "\<Space>"

	" For cursor moving in insert mode(Not recommended)
	"inoremap <expr><Left>  neocomplete#close_popup() . "\<Left>"
	"inoremap <expr><Right> neocomplete#close_popup() . "\<Right>"
	"inoremap <expr><Up>    neocomplete#close_popup() . "\<Up>"
	"inoremap <expr><Down>  neocomplete#close_popup() . "\<Down>"
	" Or set this.
	"let g:neocomplete#enable_cursor_hold_i = 1
	" Or set this.
	"let g:neocomplete#enable_insert_char_pre = 1

	" AutoComplPop like behavior.
	"let g:neocomplete#enable_auto_select = 1

	" Shell like behavior(not recommended).
	"set completeopt+=longest
	"let g:neocomplete#enable_auto_select = 1
	"let g:neocomplete#disable_auto_complete = 1
	"inoremap <expr><TAB>  pumvisible() ? "\<Down>" : "\<C-x>\<C-u>"

	" Enable omni completion.
	autocmd NoraAutoCmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
	autocmd NoraAutoCmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
	autocmd NoraAutoCmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
	autocmd NoraAutoCmd FileType python setlocal omnifunc=pythoncomplete#Complete
	autocmd NoraAutoCmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags

	" Enable heavy omni completion.
	if !exists('g:neocomplete#sources#omni#input_patterns')
	  let g:neocomplete#sources#omni#input_patterns = {}
	endif
	"let g:neocomplete#sources#omni#input_patterns.php = '[^. \t]->\h\w*\|\h\w*::'
	"let g:neocomplete#sources#omni#input_patterns.c = '[^.[:digit:] *\t]\%(\.\|->\)'
	"let g:neocomplete#sources#omni#input_patterns.cpp = '[^.[:digit:] *\t]\%(\.\|->\)\|\h\w*::'

	" For perlomni.vim setting.
	" https://github.com/c9s/perlomni.vim
	let g:neocomplete#sources#omni#input_patterns.perl = '\h\w*->\h\w*\|\h\w*::'
else
	" ä»Šã¾ã§ã® neocomplcache ã®è¨­å®š
endif
" }}}

" Vimshell {{{

":VimShell [{options}...] [{path}]		*:VimShell*
":VimShellCreate [{options}...] [{path}]		*:VimShellCreate*
":VimShellTab [{options}...] [{path}]		*:VimShellTab*
":VimShellPop [{options}...] [{path}]		*:VimShellPop*
":VimShellCurrentDir [{options}...] [{path}]	*:VimShellCurrentDir*
":VimShellBufferDir [{options}...] [{path}]	*:VimShellBufferDir*
":VimShellExecute [{option}] [{command}]			*:VimShellExecute*
":VimShellInteractive [{option}] [{command}]		*:VimShellInteractive*
":[range]VimShellSendString {string}		*:VimShellSendString*
":VimShellSendBuffer {bufname}			*:VimShellSendBuffer*
":VimShellClose [{buffer-name}]			*:VimShellClose*

" }}}


" }}}

" Hack {{{

" Use vsplit mode
if has("vim_starting") && !has('gui_running') && has('vertsplit')
 function! g:EnableVsplitMode()
   " enable origin mode and left/right margins
   let &t_CS = "y"
   let &t_ti = &t_ti . "\e[?6;69h"
   let &t_te = "\e[?6;69l\e[999H" . &t_te
   let &t_CV = "\e[%i%p1%d;%p2%ds"
   call writefile([ "\e[?6;69h" ], "/dev/tty", "a")
 endfunction

 " old vim does not ignore CPR
 map <special> <Esc>[3;9R <Nop>

 " new vim can't handle CPR with direct mapping
 " map <expr> ^[[3;3R g:EnableVsplitMode()
 set t_F9=[3;3R
 map <expr> <t_F9> g:EnableVsplitMode()
 let &t_RV .= "\e[?6;69h\e[1;3s\e[3;9H\e[6n\e[0;0s\e[?6;69l"
endif

command! -nargs=0 JunkFile call s:open_junk_file()
function! s:open_junk_file()
    let l:junk_dir = $HOME . '/.vim_junk'. strftime('/%Y/%m')
    if !isdirectory(l:junk_dir)
        call mkdir(l:junk_dir, 'p')
    endif

    let l:filename = input('Junk Code: ', l:junk_dir.strftime('/%Y-%m-%d-%H%M%S.'))
    if l:filename != ''
        execute 'edit ' . l:filename
    endif
endfunction

" }}}

" Quickrun {{{

let s:bundle = neobundle#get("vim-quickrun")
let g:quickrun_config = {
\   "_" : {
\       "hook/close_unite_quickfix/enable_hook_loaded" : 1,
\       "hook/unite_quickfix/enable_failure" : 1,
\       "hook/close_quickfix/enable_exit" : 1,
\       "hook/close_buffer/enable_failure" : 1,
\       "hook/close_buffer/enable_empty_data" : 1,
\       "runner" : "vimproc",
\       "runner/vimproc/updatetime" : 60,
\       "outputter" : "multi:buffer:quickfix",
\       "outputter/buffer/split" : ":botright 18sp",
\   },
\}

nnoremap <silent> [nora:ext]r : <C-u>QuickRun<CR>

" }}}

" ãƒã‚ªãƒãƒ³ãƒ‰ãƒ«ç”¨ã®çµ‚äº† {{{
call neobundle#end()
filetype plugin indent on
" }}}
" vim: set ft=vim ts=4 sw=4 sts=4 foldmethod=marker :
"
" VIMè¨­å®šãƒ•ã‚¡ã‚¤ãƒ«
"
" @Author Hajime <mail@hazime.org>
" @Update 2014.10.10
" @See http://motw.mods.jp/Vim/command.html

nnoremap rv :<C-u>source ~/.vimrc<CR>

" NeoBundleç”¨ã®ã‚¹ã‚¿ãƒ¼ãƒˆã‚¢ãƒƒãƒ— {{{
filetype plugin indent off
if has('vim_starting')
  set runtimepath+=~/.dotfiles/vim/third/neobundle.vim/
endif
" Start Neo Bundle
call neobundle#begin(expand('~/.dotfiles/vim/bundle/'))
" }}}

" Auto Command {{{
function! s:RestoreCursorPostion()
    if line("'\"") <= line("$")
        normal! g`"
        return 1
    endif
endfunction

augroup NoraAutoCmd
  autocmd!
  autocmd BufWinEnter * call s:RestoreCursorPostion()
augroup END

" }}}

" ãƒ—ãƒ¬ãƒ•ã‚£ãƒƒã‚¯ã‚¹ã®è¨­å®š {{{
nmap s <Nop>
nnoremap [nora] <NOP>
nmap s <ESC>[nora]
nmap <C-f> <ESC>[nora]
imap <c-f> <ESC>[nora]

nnoremap [nora:mode] <NOP>
nmap m [nora:mode]

nnoremap [nora:mode]s <esc>[vimshell]

nnoremap [nora:ext] <Nop>
nmap <space> <ESC>[nora:ext]

nnoremap [search] <nop>
nmap [nora]g <esc>[search]
" }}}

" ãƒ™ãƒ¼ã‚·ãƒƒã‚¯ã‚»ãƒƒãƒ†ã‚£ãƒ³ã‚° {{{

" VIã¨ã®äº’æ›æ€§ã‚’ä¿ãŸãªã„
set nocompatible

" ãƒ•ã‚¡ã‚¤ãƒ«ãƒ­ã‚±ãƒ¼ã‚·ãƒ§ãƒ³
set directory=~/.vim.tmp//
set backupdir=~/.vim.tmp//

" Swapã¯ä½¿ã‚ãªã„
set noswapfile
" ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã¯ä½¿ã†
set backup

" VIMã‚³ãƒãƒ³ãƒ‰å±¥æ­´ä¿æŒæ•°
set viminfo='100
" VIMãƒ¬ã‚¸ã‚¹ãƒˆãƒªä¿æŒæ•°
set viminfo+="1000
" VIMINFOä¿å­˜ãƒ•ã‚¡ã‚¤ãƒ«
set viminfo+=n~/.vim.info

"
" åŒæ™‚ç·¨é›†ãŒç™ºç”Ÿã—ãŸæ™‚ã®æŒ™å‹•
"

" ä»–ã®å ´æ‰€ã§æ›´æ–°ã•ã‚ŒãŸã‚‰è‡ªå‹•çš„ã«èª­ã¿è¾¼ã‚€
set autoread

" ãƒãƒƒã‚¯ã‚¹ãƒšãƒ¼ã‚¹ã§å‰Šé™¤å¯èƒ½ãªã‚‚ã®ã‚’å¢—ã‚„ã™
set backspace=start,eol,indent


"
" æ¤œç´¢ã®æŒ™å‹•
"

" æ¤œç´¢æ™‚ã«å¤§æ–‡å­—å°æ–‡å­—ã‚’ç„¡è¦–
set ignorecase

" ãŸã ã—ã€æ¤œç´¢æ–‡å­—ã«å¤§æ–‡å­—å°æ–‡å­—ãŒã‚ã‚Œã°ç„¡è¦–ã—ãªã„
set smartcase  " do not ignore capital when search words includs both

" æ¤œç´¢æ–‡å­—ã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆã—ãªã„
set nohlsearch

"
" TTYã®è¨­å®š
"
set lazyredraw
set ttyfast

" ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦å¹…ã§æŠ˜ã‚Šè¿”ã™
set nowrap

" å›ºå®šæŠ˜ã‚Šè¿”ã—æ–‡å­—å¹…ã‚’æŒãŸãªã„
set textwidth=0

" è¡Œç•ªå·ã‚’è¡¨ç¤ºã™ã‚‹
set number

set scrolloff=16

" }}}

" æŠ˜ã‚ŠãŸãŸã¿ {{{
"set foldtext=FoldCCtext()
set foldcolumn=3
set fillchars=vert:\|
hi Folded gui=bold term=standout ctermbg=LightGrey ctermfg=DarkBlue guibg=Grey30 guifg=Grey80
hi FoldColumn gui=bold term=standout ctermbg=LightGrey ctermfg=DarkBlue guibg=Grey guifg=DarkBlue

" }}}

" ã‚¿ãƒ–ç³»ã®è¨­å®š {{{
set tabstop=4
set softtabstop=4
set shiftwidth=4
set expandtab
" }}}

" ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒ©ã‚¤ãƒ³ã®è¨­å®š {{{
set laststatus=2
"set showmode
set noshowmode
set showcmd
set wildmenu
set ruler

NeoBundle 'itchyny/lightline.vim'
" wonbat solarized landscape
let g:lightline = {
      \ 'colorscheme': 'jellybeans',
      \ 'component': {
      \   'readonly': '%{&readonly?"î‚¢":""}',
      \ },
      \ 'separator': { 'left': 'î‚°', 'right': 'î‚²' },
      \ 'subseparator': { 'left': 'î‚±', 'right': 'î‚³' }
      \ }
 
let g:lightline = {
      \ 'colorscheme': 'jellybeans',
      \ 'active': {
      \   'left': [ [ 'mode', 'paste' ], [ 'fugitive', 'filename' ], ['ctrlpmark'] ],
      \   'right': [ [ 'syntastic', 'lineinfo' ], ['percent'], [ 'fileformat', 'fileencoding', 'filetype' ] ]
      \ },
      \ 'component': {
      \   'readonly': '%{&readonly?"î‚¢":""}',
      \ },
      \ 'component_function': {
      \   'fugitive': 'MyFugitive',
      \   'filename': 'MyFilename',
      \   'fileformat': 'MyFileformat',
      \   'filetype': 'MyFiletype',
      \   'fileencoding': 'MyFileencoding',
      \   'mode': 'MyMode',
      \   'ctrlpmark': 'CtrlPMark',
      \ },
      \ 'component_expand': {
      \   'syntastic': 'SyntasticStatuslineFlag',
      \ },
      \ 'component_type': {
      \   'syntastic': 'error',
      \ },
      \ 'separator': { 'left': 'î‚°', 'right': 'î‚²' },
      \ 'subseparator': { 'left': 'î‚±', 'right': 'î‚³' }
      \ }

function! MyModified()
  return &ft =~ 'help' ? '' : &modified ? '+' : &modifiable ? '' : '-'
endfunction

function! MyReadonly()
  return &ft !~? 'help' && &readonly ? 'RO' : ''
endfunction

function! MyFilename()
  let fname = expand('%:t')
  return fname == 'ControlP' ? g:lightline.ctrlp_item :
        \ fname == '__Tagbar__' ? g:lightline.fname :
        \ fname =~ '__Gundo\|NERD_tree' ? '' :
        \ &ft == 'vimfiler' ? vimfiler#get_status_string() :
        \ &ft == 'unite' ? unite#get_status_string() :
        \ &ft == 'vimshell' ? vimshell#get_status_string() :
        \ ('' != MyReadonly() ? MyReadonly() . ' ' : '') .
        \ ('' != fname ? fname : '[No Name]') .
        \ ('' != MyModified() ? ' ' . MyModified() : '')
endfunction

function! MyFugitive()
  try
    if expand('%:t') !~? 'Tagbar\|Gundo\|NERD' && &ft !~? 'vimfiler' && exists('*fugitive#head')
      let mark = ''  " edit here for cool mark
      let _ = fugitive#head()
      return strlen(_) ? mark._ : ''
    endif
  catch
  endtry
  return ''
endfunction

function! MyFileformat()
  return winwidth(0) > 70 ? &fileformat : ''
endfunction

function! MyFiletype()
  return winwidth(0) > 70 ? (strlen(&filetype) ? &filetype : 'no ft') : ''
endfunction

function! MyFileencoding()
  return winwidth(0) > 70 ? (strlen(&fenc) ? &fenc : &enc) : ''
endfunction

function! MyMode()
  let fname = expand('%:t')
  return fname == '__Tagbar__' ? 'Tagbar' :
        \ fname == 'ControlP' ? 'CtrlP' :
        \ fname == '__Gundo__' ? 'Gundo' :
        \ fname == '__Gundo_Preview__' ? 'Gundo Preview' :
        \ fname =~ 'NERD_tree' ? 'NERDTree' :
        \ &ft == 'unite' ? 'Unite' :
        \ &ft == 'vimfiler' ? 'VimFiler' :
        \ &ft == 'vimshell' ? 'VimShell' :
        \ winwidth(0) > 60 ? lightline#mode() : ''
endfunction

function! CtrlPMark()
  if expand('%:t') =~ 'ControlP'
    call lightline#link('iR'[g:lightline.ctrlp_regex])
    return lightline#concatenate([g:lightline.ctrlp_prev, g:lightline.ctrlp_item
          \ , g:lightline.ctrlp_next], 0)
  else
    return ''
  endif
endfunction

let g:ctrlp_status_func = {
  \ 'main': 'CtrlPStatusFunc_1',
  \ 'prog': 'CtrlPStatusFunc_2',
  \ }

function! CtrlPStatusFunc_1(focus, byfname, regex, prev, item, next, marked)
  let g:lightline.ctrlp_regex = a:regex
  let g:lightline.ctrlp_prev = a:prev
  let g:lightline.ctrlp_item = a:item
  let g:lightline.ctrlp_next = a:next
  return lightline#statusline(0)
endfunction

function! CtrlPStatusFunc_2(str)
  return lightline#statusline(0)
endfunction

let g:tagbar_status_func = 'TagbarStatusFunc'

function! TagbarStatusFunc(current, sort, fname, ...) abort
    let g:lightline.fname = a:fname
  return lightline#statusline(0)
endfunction

augroup AutoSyntastic
  autocmd!
  autocmd BufWritePost *.c,*.cpp call s:syntastic()
augroup END
function! s:syntastic()
  SyntasticCheck
  call lightline#update()
endfunction

let g:unite_force_overwrite_statusline = 0
let g:vimfiler_force_overwrite_statusline = 0
let g:vimshell_force_overwrite_statusline = 0

" set statusline=%<     " è¡ŒãŒé•·ã™ãã‚‹ã¨ãã«åˆ‡ã‚Šè©°ã‚ã‚‹ä½ç½®
" set statusline+=[%n]  " ãƒãƒƒãƒ•ã‚¡ç•ªå·
" set statusline+=%m    " %m ä¿®æ­£ãƒ•ãƒ©ã‚°
" set statusline+=%r    " %r èª­ã¿è¾¼ã¿å°‚ç”¨ãƒ•ãƒ©ã‚°
" set statusline+=%h    " %h ãƒ˜ãƒ«ãƒ—ãƒãƒƒãƒ•ã‚¡ãƒ•ãƒ©ã‚°
" set statusline+=%w    " %w ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒ•ãƒ©ã‚°
" set statusline+=%{'['.(&fenc!=''?&fenc:&enc).':'.&ff.']'}  " fencã¨ffã‚’è¡¨ç¤º
" set statusline+=%y    " ãƒãƒƒãƒ•ã‚¡å†…ã®ãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚¿ã‚¤ãƒ—
" set statusline+=\     " ç©ºç™½ã‚¹ãƒšãƒ¼ã‚¹
" if winwidth(0) >= 130
"     set statusline+=%F    " ãƒãƒƒãƒ•ã‚¡å†…ã®ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ•ãƒ«ãƒ‘ã‚¹
" else
"     set statusline+=%t    " ãƒ•ã‚¡ã‚¤ãƒ«åã®ã¿
" endif
" set statusline+=%=    " å·¦å¯„ã›é …ç›®ã¨å³å¯„ã›é …ç›®ã®åŒºåˆ‡ã‚Š
" set statusline+=%{fugitive#statusline()}  " Gitã®ãƒ–ãƒ©ãƒ³ãƒåã‚’è¡¨ç¤º
" set statusline+=\ \   " ç©ºç™½ã‚¹ãƒšãƒ¼ã‚¹2å€‹
" set statusline+=%1l   " ä½•è¡Œç›®ã«ã‚«ãƒ¼ã‚½ãƒ«ãŒã‚ã‚‹ã‹
" set statusline+=/
" set statusline+=%L    " ãƒãƒƒãƒ•ã‚¡å†…ã®ç·è¡Œæ•°
" set statusline+=,
" set statusline+=%c    " ä½•åˆ—ç›®ã«ã‚«ãƒ¼ã‚½ãƒ«ãŒã‚ã‚‹ã‹
" set statusline+=%V    " ç”»é¢ä¸Šã®ä½•åˆ—ç›®ã«ã‚«ãƒ¼ã‚½ãƒ«ãŒã‚ã‚‹ã‹
" set statusline+=\ \   " ç©ºç™½ã‚¹ãƒšãƒ¼ã‚¹2å€‹
" set statusline+=%P    " ãƒ•ã‚¡ã‚¤ãƒ«å†…ã®ä½•ï¼…ã®ä½ç½®ã«ã‚ã‚‹ã‹

" }}}

" æ—¥æœ¬èªé–¢é€£ {{{

" æ–‡å­—ã‚³ãƒ¼ãƒ‰åˆ¤å®šé †åº
set fileencodings=utf-8,euc-jp,iso-2022-jp,cp932

" }}}

" ã‚·ãƒ³ã‚¿ãƒƒã‚¯ã‚¹ {{{
syntax enable
" }}}

" NeoBundle {{{
NeoBundleFetch 'Shougo/neobundle.vim'

" Vim Procã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
NeoBundle 'Shougo/vimproc',{'build': 
\ {
\   'windows': 'make -f make_windows.mak',
\   'cygwin': 'make -f make_cygwin.mak',
\   'mac': 'make -f make_mac.mak',
\   'unix': 'make -f make_unix.mak',
\ }
\}

NeoBundleLazy 'thinca/vim-quickrun', {
            \ 'autoload' : {
            \     'commands' : [ 'QuickRun' ]
            \  }
            \}

NeoBundleLazy 'Shougo/vimfiler.vim', {
\   'autoload' : { 'commands' : [ 'VimFiler', 'VimFilerTab', 'VimFilerExplorer', 'VimFilerBufferDir', 'VimFilerCreate' ] },
\   'depends': [ 'Shougo/unite.vim' ],
\ }

NeoBundleLazy 'Shougo/unite.vim' , {
\   'autoload' : { 'commands' : [ 'Unite' ] }
\ }

" VimShell
NeoBundleLazy 'Shougo/vimshell', {'depends': ['Shougo/vimproc']}


" Uniteãƒ—ãƒ©ã‚°ã‚¤ãƒ³
NeoBundleLazy 'Shougo/unite-outline'
" NeoBundleLazy 'ujihisa/unite-colorscheme'
NeoBundleLazy 'tacroe/unite-mark'
NeoBundleLazy 'osyo-manga/unite-fold'
" NeoBundleLazy 'taka84u9/unite-git'
" NeoBundleLazy 'thinca/vim-unite-history'
" NeoBundleLazy 'kannokanno/unite-dwm'
NeoBundleLazy 'tsukkee/unite-tag'


NeoBundleLazy 'thinca/vim-ref', {
\ 'autoload' : {'commands': [ 'Ref' ] },
\ 'depends' : ["mfumi/ref-dicts-en"]
\}
NeoBundleLazy 'mfumi/ref-dicts-en'

"
" ãƒ¡ãƒ¢å¸³
"
" @See https://sites.google.com/site/fudist/Home/qfixhowm/install
NeoBundleLazy 'fuenor/qfixgrep'
NeoBundleLazy 'fuenor/qfixhowm'
NeoBundleLazy "osyo-manga/unite-qfixhowm"


NeoBundleLazy "sjl/gundo.vim", {"autoload": {"commands": ['GundoToggle'],}}
NeoBundleLazy 'majutsushi/tagbar', {"autload": {"commands": ["TagbarToggle"],}}

NeoBundleLazy 'plasticboy/vim-markdown', {"autoload": {"filetypes": ["markdown"]}}

" ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆã‚’ã‚ã‹ã‚Šã‚„ã™ãã™ã‚‹
NeoBundleLazy  'nathanaelkane/vim-indent-guides'

" VimTemplate
NeoBundleLazy "thinca/vim-template"


" ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªå˜ä½ã§ã®vimrcã‚’æœ‰åŠ¹ã«ã™ã‚‹
NeoBundleLazy 'thinca/vim-localrc'

" ctagsã‚’è‡ªå‹•åŒ–
NeoBundleLazy 'soramugi/auto-ctags.vim'

"
" ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ç”¨
"
" HTML5ã‚·ãƒ³ã‚¿ãƒƒã‚¯ã‚¹ã‚’æœ‰åŠ¹ã«ã™ã‚‹
NeoBundleLazy 'othree/html5.vim.git', {"autoload": {"filetypes": ['html']}}

" CoffeeScriptç”¨ãƒ—ãƒ©ã‚°ã‚¤ãƒ³
NeoBundleLazy 'kchmck/vim-coffee-script', {"autoload": {"filetype": ["coffee"]}}

" Align
NeoBundleLazy 'h1mesuke/vim-alignta.git', {"autoload": {"commands": ["Align"]}}

" TagList
NeoBundleLazy 'taglist.vim'

" ã‚¿ã‚°ã‚¸ãƒ£ãƒ³ãƒ—
NeoBundleLazy  'szw/vim-tags'

"Dockerfile Syntax
NeoBundleLazy 'ekalinin/Dockerfile.vim', {"autoload": {"filetype": ["dockerfile"]}}

"Vagrant Syntax
NeoBundleLazy 'markcornick/vim-vagrant', {"autoload": {"filetype": ["vagrantfile"]}}

"Tmux Syntax
NeoBundleLazy 'Keithbsmiley/tmux.vim', {"autoload": {"filetype": ["tmux"]}}

" Powerline
NeoBundleLazy 'Lokaltog/powerline', { 'rtp' : 'powerline/bindings/vim' }
NeoBundleLazy 'Lokaltog/powerline-fontpatcher'

" HTMLé–‰ã˜ã‚¿ã‚°å¾Œã®ã‚³ãƒ¡ãƒ³ãƒˆã‚’,tã§å…¥åŠ›
NeoBundleLazy 'haya14busa/endtagcomment.vim', {"autoload": {"filetype": ["html"]}}

" ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆç®¡ç†
" NeoBundle 'project.vim'
NeoBundleLazy 'kien/ctrlp.vim', {"autoload": {"commands": ["CtrlP", "CtrlPMRUFiles"]}}

" ãƒ¡ãƒ¢
NeoBundleLazy 'glidenote/memolist.vim', {"autoload": {"commands": ["MemoList"]}}

" }}}

" è¨­å®š {{{
NeoBundle 'kana/vim-textobj-user'

" Submoduleã‚’æœ‰åŠ¹ã«ã™ã‚‹
NeoBundle  'kana/vim-submode'

" Gitã‚’ä¾¿åˆ©ã«ä½¿ã†
NeoBundle 'tpope/vim-fugitive'

" ã‚³ãƒ¡ãƒ³ãƒˆON/OFFã‚’æ‰‹è»½ã«å®Ÿè¡Œ (gcc)
NeoBundle 'tomtom/tcomment_vim'

" Tabå˜ä½ã§ã®cdã‚’æœ‰åŠ¹ã«ã™ã‚‹
NeoBundle 'kana/vim-tabpagecd'

" ã‚«ãƒ©ãƒ¼ã‚¹ã‚­ãƒ¼ãƒ
NeoBundle 'nanotech/jellybeans.vim'
let s:bundle = neobundle#get('jellybeans.vim')
function! s:bundle.hooks.on_source(bundle)
    colorscheme jellybeans
endfunction

" Undoã‚’ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‰ã˜ãŸå¾Œã‚‚æœ‰åŠ¹ã«ã™ã‚‹
if has('persistent_undo')
    set undofile
    set undodir=$HOME/.vim.tmp
endif 

" ã‚­ãƒ¼ãƒã‚¤ãƒ³ãƒ‰ {{{

" é–“é•ãˆãã†ãªãƒã‚¤ãƒ³ãƒ‰ã‚’èª¿æ•´(äº‹æ•…ã®ç´ ) {{{
nnoremap ZZ <Nop>
nnoremap ZQ <Nop>
nnoremap Q <Nop>
inoremap <F1> <ESC>
nnoremap <F1> <ESC>
vnoremap <F1> <ESC>
nnoremap ; :
cmap w1 w! 
cmap q1 q! 
" }}}

" VIã‚’ã‚‚ã£ã¨ç›´æ„Ÿçš„ã«ã™ã‚‹ {{{
nnoremap j gj
nnoremap k gk
nnoremap gj j
nnoremap gk k
inoremap jj <ESC>

" ã‚«ãƒ¼ã‚½ãƒ«ä¸‹ã®å˜èªã‚’ * ã§æ¤œç´¢
vnoremap <silent> * "vy/\V<C-r>=substitute(escape(@v, '\/'), "\n", '\\n', 'g')<CR><CR>

" æ¤œç´¢å¾Œã«ã‚¸ãƒ£ãƒ³ãƒ—ã—ãŸéš›ã«æ¤œç´¢å˜èªã‚’ç”»é¢ä¸­å¤®ã«æŒã£ã¦ãã‚‹
nnoremap n nzz
nnoremap N Nzz
nnoremap * *zz
nnoremap # #zz
nnoremap g* g*zz
nnoremap g# g#zz

" vã‚’äºŒå›ã§è¡Œæœ«ã¾ã§é¸æŠ
vnoremap v $h

set showmatch           " å¯¾å¿œã™ã‚‹æ‹¬å¼§ãªã©ã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆè¡¨ç¤ºã™ã‚‹
set matchtime=3         " å¯¾å¿œæ‹¬å¼§ã®ãƒã‚¤ãƒ©ã‚¤ãƒˆè¡¨ç¤ºã‚’3ç§’ã«ã™ã‚‹
" å¯¾å¿œæ‹¬å¼§ã«'<'ã¨'>'ã®ãƒšã‚¢ã‚’è¿½åŠ 
set matchpairs& matchpairs+=<:>
" ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆä¸å¯è¦–æ–‡å­—ã¯ç¾ã—ããªã„ã®ã§Unicodeã§ç¶ºéº—ã«
set listchars=tab:Â»-,trail:-,extends:Â»,precedes:Â«,nbsp:%,eol:â†²
" }}}

" ãƒã‚¦ã‚¹ã®è¨­å®š {{{

" ãƒã‚¦ã‚¹ã®æœ‰åŠ¹ç„¡åŠ¹
nnoremap <F3> :call ToggleMouse()<CR>
inoremap <F3> :call ToggleMouse()<CR>
function! ToggleMouse()
	if &mouse == 'a'
		set mouse =
		echo "Mouse usage disabled"
	else
		set mouse=a
		echo "Mouse usage enabled"
	endif
endfunction
" }}}

" ãƒ¢ãƒ¼ãƒ‰ãƒˆã‚°ãƒ« {{{
nmap <silent> [nora:mode]p :<C-u>set paste!<CR>
nmap <silent> [nora:mode]m :<C-u>call ToggleMouse()<CR>
" }}}

" w!!ã§sudoçµŒç”±ã§ä¿å­˜
cmap w!! w !sudo tee > /dev/null %

" }}}

" ã‚¦ã‚¤ãƒ³ãƒ‰ã‚¦æ“ä½œç³» {{{

NeoBundle 'Shougo/neomru.vim'

nmap <silent> [nora]j <C-w>j
nmap <silent> [nora]k <C-w>k
nmap <silent> [nora]l <C-w>l
nmap <silent> [nora]h <C-w>h
nmap <silent> [nora]<C-j> <C-w>j
nmap <silent> [nora]<C-k> <C-w>k
nmap <silent> [nora]<C-l> <C-w>l
nmap <silent> [nora]<C-h> <C-w>h
nnoremap [nora]= <C-w>=
nnoremap [nora]> <C-w>>
nnoremap [nora]< <C-w><
nnoremap [nora]+ <C-w>+
nnoremap [nora]- <C-w>-
let s:bundle = neobundle#get("vim-submode")
function! s:bundle.hooks.on_source(bundle)
    call submode#enter_with('windowi', 'n', '', 's>', '<C-w>>')
    call submode#enter_with('windowi', 'n', '', 's<', '<C-w><')
    call submode#enter_with('windowi', 'n', '', 's+', '<C-w>+')
    call submode#enter_with('windowi', 'n', '', 's-', '<C-w>-')
    call submode#map('windowi', 'n', '', '>', '<C-w>>')
    call submode#map('windowi', 'n', '', '<', '<C-w><')
    call submode#map('windowi', 'n', '', '+', '<C-w>+')
    call submode#map('windowi', 'n', '', '-', '<C-w>-')
endfunction

" ã‚¨ã‚¯ã‚¹ãƒ—ãƒ­ãƒ¼ãƒ©ã‚’é–‹ã
nnoremap <silent> [nora:ext]e :<C-u>VimFilerCreate -split -simple -winwidth=35 -no-quit<CR>
nnoremap <silent> [nora]<C-e> :<C-u>VimFilerBufferDir -split -simple -winwidth=35 -no-quit<CR>

" ã‚¿ã‚°ãƒãƒ¼ã‚’é–‹ã
nnoremap <silent> [nora:ext]t :<C-u>TagbarToggle<CR>
" gundo
nnoremap <silent> [nora:ext]g :<C-u>GundoToggle<CR>


" }}}

" Uniteç³» {{{
nnoremap <silent> [nora]b :<C-u>Unite buffer bookmark<CR>
nnoremap <silent> [nora]o :<C-u>Unite fold outline<CR>
nnoremap <silent> [nora]<C-h> :<C-u>Unite buffer file_mru<CR>
nnoremap <silent> [nora]c :<C-u>UniteWithBufferDir file file/new directory/new<CR>
nnoremap <silent> [nora]q :<C-u>Unite qfixhowm qfixhowm/new <CR>
nnoremap <silent> [nora]<C-q> :<C-u>Unite qfixhowm qfixhowm/new <CR>
nnoremap <silent> [nora]<C-c> :<C-u>UniteWithBufferDir file file/new directory/new<CR>
nnoremap <silent> [nora]y :<C-u>Unite history/yank<CR>

let s:bundle = neobundle#get("unite.vim")
function! s:bundle.hooks.on_source(bundle)
    let g:unite_enable_start_insert=1
    let g:unite_source_history_yank_enable =1
    let g:unite_source_file_mru_limit = 200
endfunction


autocmd NoraAutoCmd FileType unite call s:unite_my_settings()
function! s:unite_my_settings()
    nnoremap <silent> <buffer> <expr> <C-T> unite#do_action('tabopen')
    inoremap <silent> <buffer> <expr> <C-T> unite#do_action('tabopen')
    nnoremap <silent> <buffer> <expr> t unite#do_action('tabopen')
    nnoremap <silent> <buffer> <expr> o unite#do_action('split')
    nnoremap <silent> <buffer> <expr> <C-O> unite#do_action('split')
    inoremap <silent> <buffer> <expr> <C-O> unite#do_action('split')
    nnoremap <silent> <buffer> <expr> <C-V> unite#do_action('vsplit')
    inoremap <silent> <buffer> <expr> <C-V> unite#do_action('vsplit')
    inoremap <silent> <buffer> <expr> <C-V> unite#do_action('vsplit')
    nnoremap <silent> <buffer> <ESC><ESC> :q<CR>
    inoremap <silent> <buffer> <ESC><ESC> <ESC>:q<CR>
    imap <buffer> <C-k>     <Plug>(unite_select_previous_line)
    imap <buffer> <C-j>     <Plug>(unite_select_next_line)
endfunction
" }}}

" ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ“ä½œ(CtrlP) {{{
let s:bundle = neobundle#get("ctrlp.vim")
function! s:bundle.hooks.on_source(bundle)
    let g:ctrlp_map = '<Nop>'
    let g:ctrlp_working_path_mode = 'ra'
    let g:ctrlp_open_new_file = 'r'
    let g:ctrlp_extensions = ['tag', 'quickfix', 'dir', 'line', 'mixed']
    let g:ctrlp_max_files  = 100000 " å¯¾è±¡ãƒ•ã‚¡ã‚¤ãƒ«æœ€å¤§æ•°(default:10000)
    let g:ctrlp_max_depth = 10 " æ¤œç´¢å¯¾è±¡ã®æœ€å¤§éšå±¤æ•°(default:40)
    let g:ctrlp_clear_cache_on_exit = 0 " vimçµ‚äº†æ™‚ã«ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¯ãƒªã‚¢ã—ãªã„(default:1)
    let g:ctrlp_match_window = 'bottom,order:btt,min:1,max:18,results:50' " æ¤œç´¢ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®è¨­å®š
endfunction
nnoremap [nora]m :<C-u>CtrlPMRUFiles<CR> 
" }}}

" HTMLæ“ä½œ {{{
nmap [nora]et <Plug>(endtagcomment)
" }}}

" è¾æ›¸: vim-ref {{{
" vimshell% cd ~/.vim/
" vimshell% curl -sSL "http://jp1.php.net/get/php_manual_ja.tar.gz/from/this/mirror" | tar zxvf -
"
nnoremap [ref] <Nop>
nmap [nora]r [ref]

"Ref webdictã§alcã‚’ä½¿ã†è¨­å®š
let g:ref_source_webdict_cmd = 'lynx -dump -nonumbers %s'
"let g:ref_source_webdict_use_cache = 1
let g:ref_source_webdict_sites = {
            \ 'alc' : {
            \   'url' : 'http://eow.alc.co.jp/%s/UTF-8/',
            \   'cache' : 1
            \   },
            \ 'wiktionary' : {
            \   'url' : 'http://ja.wiktionary.org/wiki/%s',
            \   'keyword_encoding': 'utf-8',
            \   'cache' : 1
            \   }
            \ }
function! g:ref_source_webdict_sites.alc.filter(output)
      return join(split(a:output, "\n")[42 :], "\n")
endfunction

let g:ref_phpmanual_path = "/opt/vim/php-chunked-xhtml/"
nmap [ref]a :<C-u>Ref webdict alc 
nmap [ref]w :<C-u>Ref webdict wiktionary 
nmap [ref]p :<C-u>Ref phpmanual 
" }}}

" ãƒ¡ãƒ¢ {{{

" memolist {{{
let g:memolist_qfixgrep = 1
let g:memolist_memo_suffix = "md"
let g:memolist_memo_date = "%Y-%m-%d %H:%M"
let g:memolist_memo_date = "epoch"
let g:memolist_memo_date = "%d %t"
let g:memolist_prompt_tags = 1
let g:memolist_prompt_categories = 1
let g:memolist_qfixgrep = 1
let g:memolist_vimfiler = 1
let g:memolist_template_dir_path = "~/memo/memolist"
map [nora:ext]ml  :MemoList<cr>
map [nora:ext]mn  :MemoNew<cr>
map [nora:ext]mg  :MemoGrep<cr>
" }}}

" QFixHowm {{{
" ãƒ¡ãƒ¢æ©Ÿèƒ½
"set QFixHowm_Key = '<nop>'
 
let howm_dir             = '~/memo/hown'

" ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³è¨˜æ³•ã‚’ä½¿ã†
"let QFixHowm_FileType = 'markdown'
"let QFixHowm_Title = '#'
"let QFixMRU_Title = {}
"let QFixMRU_Title['mkd']       = '^###[^#]'
"let QFixMRU_Title['mkd_regxp'] = '^###[^#]'
au BufRead,BufNewFile *.md set filetype=markdown

" ãƒ•ã‚¡ã‚¤ãƒ«æ‹¡å¼µå­ã‚’mdã«ã™ã‚‹
let howm_filename = '%Y/%m/%Y-%m-%d-%H%M%S.md'
" ãƒ•ã‚¡ã‚¤ãƒ«ã‚¿ã‚¤ãƒ—ã‚’markdownã«ã™ã‚‹
let QFixHowm_FileType = 'markdown'
" ã‚¿ã‚¤ãƒˆãƒ«è¨˜å·
" let QFixHowm_Title = '#'
" ã‚¿ã‚¤ãƒˆãƒ«è¡Œæ¤œç´¢æ­£è¦è¡¨ç¾ã®è¾æ›¸ã‚’åˆæœŸåŒ–
let QFixMRU_Title = {}
" MRUã§ã‚¿ã‚¤ãƒˆãƒ«è¡Œã¨ã¿ãªã™æ­£è¦è¡¨ç¾(Vimã®æ­£è¦è¡¨ç¾ã§æŒ‡å®š)
let QFixMRU_Title['mkd'] = '^###[^#]'
" grepã§ã‚¿ã‚¤ãƒˆãƒ«è¡Œã¨ã¿ãªã™æ­£è¦è¡¨ç¾(ä½¿ç”¨ã™ã‚‹grepã«ã‚ˆã£ã¦ã¯å¤‰æ›´ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™)
let QFixMRU_Title['mkd_regxp'] = '^###[^#]'
" }}}

" }}}

" Grepç³» {{{
nnoremap <silent> [search] :<C-u>Unite grep:. -buffer-name=search-buffer<CR>
" ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã®å˜èªã§æ¤œç´¢
nnoremap <silent> [search]j :<C-u>Unite grep:. -buffer-name=search-buffer<CR><C-R><C-W><CR>
" æ¤œç´¢ã®å†é–‹
nnoremap <silent> [search]k :<C-u>UniteResume search-buffer<CR>
" }}}

" Gitç³» {{{
nnoremap  [nora:ext]s :<C-u>Git status<CR>
nnoremap  [nora:ext]p :<C-u>Git push<CR>
nnoremap  [nora:ext]a :<C-u>Git add %<CR>
nnoremap  [nora:ext]c :<C-u>Git commit<CR>
nnoremap  [nora:ext]d :<C-u>Git diff %<CR>
" }}}

" Snippet {{{
" ã‚¹ãƒ‹ãƒšãƒƒãƒˆ
NeoBundle 'Shougo/neosnippet'
NeoBundle 'Shougo/neosnippet-snippets'

" Plugin key-mappings.
imap <C-k>     <Plug>(neosnippet_expand_or_jump)
smap <C-k>     <Plug>(neosnippet_expand_or_jump)
xmap <C-k>     <Plug>(neosnippet_expand_target)
 
" SuperTab like snippets behavior.
" imap <expr><TAB> neosnippet#expandable_or_jumpable() ?
" \ "\<Plug>(neosnippet_expand_or_jump)"
" \: pumvisible() ? "\<C-n>" : "\<TAB>"
" smap <expr><TAB> neosnippet#expandable_or_jumpable() ?
" \ "\<Plug>(neosnippet_expand_or_jump)"
" \: "\<TAB>"

let g:neosnippet#snippets_directory='~/.dotfiles/vim/snippets/'
nnoremap [snipet] <nop>
nmap [nora]s [snipet]
nnoremap <silent> [snipet]e :<c-u>NeoSnippetEdit<cr>
nnoremap <silent> [snipet] :<c-u>NeoSnippetEdit<cr>

" For snippet_complete marker.
if has('conceal')
  set conceallevel=2 concealcursor=i
endif

" }}}

" è£œå®Œ {{{
" Luaã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®æœ‰ç„¡ã§ä½¿ç”¨ã™ã‚‹ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚’å¤‰æ›´
function! s:meet_neocomplete_requirements()
	return has('lua') && (v:version > 703 || (v:version == 703 && has('patch885')))
endfunction

if s:meet_neocomplete_requirements()
	NeoBundle 'Shougo/neocomplete.vim'
	NeoBundleFetch 'Shougo/neocomplcache.vim'
else
	NeoBundleFetch 'Shougo/neocomplete.vim'
	NeoBundle 'Shougo/neocomplcache.vim'
endif

if neobundle#is_installed('neocomplete')
	let g:neocomplcate#enable_at_startup=1
endif
if neobundle#is_installed('neocomplcache')
	let g:neocomplcache#enable_at_startup=1
endif

"Note: This option must set it in .vimrc(_vimrc).  NOT IN .gvimrc(_gvimrc)!
" Disable AutoComplPop.
let g:acp_enableAtStartup = 0
" Use neocomplete.
if s:meet_neocomplete_requirements()
	" æ–°ã—ãè¿½åŠ ã—ãŸ neocomplete ã®è¨­å®š
	let g:neocomplete#enable_at_startup = 1
	" Use smartcase.
	let g:neocomplete#enable_smart_case = 1
	" Set minimum syntax keyword length.
	let g:neocomplete#sources#syntax#min_keyword_length = 3
	let g:neocomplete#lock_buffer_name_pattern = '\*ku\*'

	" Define dictionary.
	let g:neocomplete#sources#dictionary#dictionaries = {
		\ 'default' : '',
		\ 'vimshell' : $HOME.'/.vimshell_hist',
		\ 'scheme' : $HOME.'/.gosh_completions'
			\ }

	" Define keyword.
	if !exists('g:neocomplete#keyword_patterns')
		let g:neocomplete#keyword_patterns = {}
	endif
	let g:neocomplete#keyword_patterns['default'] = '\h\w*'

	" Plugin key-mappings.
	inoremap <expr><C-g>     neocomplete#undo_completion()
	inoremap <expr><C-l>     neocomplete#complete_common_string()

	" Recommended key-mappings.
	" <CR>: close popup and save indent.
	inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
	function! s:my_cr_function()
	  return neocomplete#close_popup() . "\<CR>"
	  " For no inserting <CR> key.
	  "return pumvisible() ? neocomplete#close_popup() : "\<CR>"
	endfunction
	" <TAB>: completion.
	inoremap <expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"
	" <C-h>, <BS>: close popup and delete backword char.
	inoremap <expr><C-h> neocomplete#smart_close_popup()."\<C-h>"
	inoremap <expr><BS> neocomplete#smart_close_popup()."\<C-h>"
	inoremap <expr><C-y>  neocomplete#close_popup()
	inoremap <expr><C-e>  neocomplete#cancel_popup()
	" Close popup by <Space>.
	"inoremap <expr><Space> pumvisible() ? neocomplete#close_popup() : "\<Space>"

	" For cursor moving in insert mode(Not recommended)
	"inoremap <expr><Left>  neocomplete#close_popup() . "\<Left>"
	"inoremap <expr><Right> neocomplete#close_popup() . "\<Right>"
	"inoremap <expr><Up>    neocomplete#close_popup() . "\<Up>"
	"inoremap <expr><Down>  neocomplete#close_popup() . "\<Down>"
	" Or set this.
	"let g:neocomplete#enable_cursor_hold_i = 1
	" Or set this.
	"let g:neocomplete#enable_insert_char_pre = 1

	" AutoComplPop like behavior.
	"let g:neocomplete#enable_auto_select = 1

	" Shell like behavior(not recommended).
	"set completeopt+=longest
	"let g:neocomplete#enable_auto_select = 1
	"let g:neocomplete#disable_auto_complete = 1
	"inoremap <expr><TAB>  pumvisible() ? "\<Down>" : "\<C-x>\<C-u>"

	" Enable omni completion.
	autocmd NoraAutoCmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
	autocmd NoraAutoCmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
	autocmd NoraAutoCmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
	autocmd NoraAutoCmd FileType python setlocal omnifunc=pythoncomplete#Complete
	autocmd NoraAutoCmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags

	" Enable heavy omni completion.
	if !exists('g:neocomplete#sources#omni#input_patterns')
	  let g:neocomplete#sources#omni#input_patterns = {}
	endif
	"let g:neocomplete#sources#omni#input_patterns.php = '[^. \t]->\h\w*\|\h\w*::'
	"let g:neocomplete#sources#omni#input_patterns.c = '[^.[:digit:] *\t]\%(\.\|->\)'
	"let g:neocomplete#sources#omni#input_patterns.cpp = '[^.[:digit:] *\t]\%(\.\|->\)\|\h\w*::'

	" For perlomni.vim setting.
	" https://github.com/c9s/perlomni.vim
	let g:neocomplete#sources#omni#input_patterns.perl = '\h\w*->\h\w*\|\h\w*::'
else
	" ä»Šã¾ã§ã® neocomplcache ã®è¨­å®š
endif
" }}}

" Vimshell {{{


:VimShell [{options}...] [{path}]		*:VimShell*
:VimShellCreate [{options}...] [{path}]		*:VimShellCreate*
:VimShellTab [{options}...] [{path}]		*:VimShellTab*
:VimShellPop [{options}...] [{path}]		*:VimShellPop*
:VimShellCurrentDir [{options}...] [{path}]	*:VimShellCurrentDir*
:VimShellBufferDir [{options}...] [{path}]	*:VimShellBufferDir*
:VimShellExecute [{option}] [{command}]			*:VimShellExecute*
:VimShellInteractive [{option}] [{command}]		*:VimShellInteractive*
:[range]VimShellSendString {string}		*:VimShellSendString*
:VimShellSendBuffer {bufname}			*:VimShellSendBuffer*
:VimShellClose [{buffer-name}]			*:VimShellClose*

" }}}


" }}}

" Hack {{{

" Use vsplit mode
if has("vim_starting") && !has('gui_running') && has('vertsplit')
 function! g:EnableVsplitMode()
   " enable origin mode and left/right margins
   let &t_CS = "y"
   let &t_ti = &t_ti . "\e[?6;69h"
   let &t_te = "\e[?6;69l\e[999H" . &t_te
   let &t_CV = "\e[%i%p1%d;%p2%ds"
   call writefile([ "\e[?6;69h" ], "/dev/tty", "a")
 endfunction

 " old vim does not ignore CPR
 map <special> <Esc>[3;9R <Nop>

 " new vim can't handle CPR with direct mapping
 " map <expr> ^[[3;3R g:EnableVsplitMode()
 set t_F9=[3;3R
 map <expr> <t_F9> g:EnableVsplitMode()
 let &t_RV .= "\e[?6;69h\e[1;3s\e[3;9H\e[6n\e[0;0s\e[?6;69l"
endif

command! -nargs=0 JunkFile call s:open_junk_file()
function! s:open_junk_file()
    let l:junk_dir = $HOME . '/.vim_junk'. strftime('/%Y/%m')
    if !isdirectory(l:junk_dir)
        call mkdir(l:junk_dir, 'p')
    endif

    let l:filename = input('Junk Code: ', l:junk_dir.strftime('/%Y-%m-%d-%H%M%S.'))
    if l:filename != ''
        execute 'edit ' . l:filename
    endif
endfunction

" }}}

" Quickrun {{{

let s:bundle = neobundle#get("vim-quickrun")
let g:quickrun_config = {
\   "_" : {
\       "hook/close_unite_quickfix/enable_hook_loaded" : 1,
\       "hook/unite_quickfix/enable_failure" : 1,
\       "hook/close_quickfix/enable_exit" : 1,
\       "hook/close_buffer/enable_failure" : 1,
\       "hook/close_buffer/enable_empty_data" : 1,
\       "runner" : "vimproc",
\       "runner/vimproc/updatetime" : 60,
\       "outputter" : "multi:buffer:quickfix",
\       "outputter/buffer/split" : ":botright 18sp",
\   },
\}

nnoremap <silent> [nora:ext]r : <C-u>QuickRun<CR>

" }}}

" ãƒã‚ªãƒãƒ³ãƒ‰ãƒ«ç”¨ã®çµ‚äº† {{{
call neobundle#end()
filetype plugin indent on
" }}}
"
" VIMè¨­å®šãƒ•ã‚¡ã‚¤ãƒ«
"
" @Author Hajime <mail@hazime.org>
" @Update 2014.10.10
" @See http://motw.mods.jp/Vim/command.html

nnoremap rv :<C-u>source ~/.vimrc<CR>

" NeoBundleç”¨ã®ã‚¹ã‚¿ãƒ¼ãƒˆã‚¢ãƒƒãƒ— {{{
filetype plugin indent off
if has('vim_starting')
  set runtimepath+=~/.dotfiles/vim/third/neobundle.vim/
endif
" Start Neo Bundle
call neobundle#begin(expand('~/.dotfiles/vim/bundle/'))
" }}}

" Auto Command {{{
function! s:RestoreCursorPostion()
    if line("'\"") <= line("$")
        normal! g`"
        return 1
    endif
endfunction

augroup NoraAutoCmd
  autocmd!
  autocmd BufWinEnter * call s:RestoreCursorPostion()
augroup END

" }}}

" ãƒ—ãƒ¬ãƒ•ã‚£ãƒƒã‚¯ã‚¹ã®è¨­å®š {{{
nmap s <Nop>
nnoremap [nora] <NOP>
nmap s <ESC>[nora]
nmap <C-f> <ESC>[nora]
imap <c-f> <ESC>[nora]

nnoremap [nora:mode] <NOP>
nmap m [nora:mode]

nnoremap [nora:mode]s <esc>[vimshell]

nnoremap [nora:ext] <Nop>
nmap <space> <ESC>[nora:ext]

nnoremap [search] <nop>
nmap [nora]g <esc>[search]
" }}}

" ãƒ™ãƒ¼ã‚·ãƒƒã‚¯ã‚»ãƒƒãƒ†ã‚£ãƒ³ã‚° {{{

" VIã¨ã®äº’æ›æ€§ã‚’ä¿ãŸãªã„
set nocompatible

" ãƒ•ã‚¡ã‚¤ãƒ«ãƒ­ã‚±ãƒ¼ã‚·ãƒ§ãƒ³
set directory=~/.vim.tmp//
set backupdir=~/.vim.tmp//

" Swapã¯ä½¿ã‚ãªã„
set noswapfile
" ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã¯ä½¿ã†
set backup

" VIMã‚³ãƒãƒ³ãƒ‰å±¥æ­´ä¿æŒæ•°
set viminfo='100
" VIMãƒ¬ã‚¸ã‚¹ãƒˆãƒªä¿æŒæ•°
set viminfo+="1000
" VIMINFOä¿å­˜ãƒ•ã‚¡ã‚¤ãƒ«
set viminfo+=n~/.vim.info

"
" åŒæ™‚ç·¨é›†ãŒç™ºç”Ÿã—ãŸæ™‚ã®æŒ™å‹•
"

" ä»–ã®å ´æ‰€ã§æ›´æ–°ã•ã‚ŒãŸã‚‰è‡ªå‹•çš„ã«èª­ã¿è¾¼ã‚€
set autoread

" ãƒãƒƒã‚¯ã‚¹ãƒšãƒ¼ã‚¹ã§å‰Šé™¤å¯èƒ½ãªã‚‚ã®ã‚’å¢—ã‚„ã™
set backspace=start,eol,indent


"
" æ¤œç´¢ã®æŒ™å‹•
"

" æ¤œç´¢æ™‚ã«å¤§æ–‡å­—å°æ–‡å­—ã‚’ç„¡è¦–
set ignorecase

" ãŸã ã—ã€æ¤œç´¢æ–‡å­—ã«å¤§æ–‡å­—å°æ–‡å­—ãŒã‚ã‚Œã°ç„¡è¦–ã—ãªã„
set smartcase  " do not ignore capital when search words includs both

" æ¤œç´¢æ–‡å­—ã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆã—ãªã„
set nohlsearch

"
" TTYã®è¨­å®š
"
set lazyredraw
set ttyfast

" ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦å¹…ã§æŠ˜ã‚Šè¿”ã™
set nowrap

" å›ºå®šæŠ˜ã‚Šè¿”ã—æ–‡å­—å¹…ã‚’æŒãŸãªã„
set textwidth=0

" è¡Œç•ªå·ã‚’è¡¨ç¤ºã™ã‚‹
set number

set scrolloff=16

" }}}

" æŠ˜ã‚ŠãŸãŸã¿ {{{
"set foldtext=FoldCCtext()
set foldcolumn=3
set fillchars=vert:\|
hi Folded gui=bold term=standout ctermbg=LightGrey ctermfg=DarkBlue guibg=Grey30 guifg=Grey80
hi FoldColumn gui=bold term=standout ctermbg=LightGrey ctermfg=DarkBlue guibg=Grey guifg=DarkBlue

" }}}

" ã‚¿ãƒ–ç³»ã®è¨­å®š {{{
set tabstop=4
set softtabstop=4
set shiftwidth=4
set expandtab
" }}}

" ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒ©ã‚¤ãƒ³ã®è¨­å®š {{{
set laststatus=2
"set showmode
set noshowmode
set showcmd
set wildmenu
set ruler

NeoBundle 'itchyny/lightline.vim'
" wonbat solarized landscape
let g:lightline = {
      \ 'colorscheme': 'jellybeans',
      \ 'component': {
      \   'readonly': '%{&readonly?"î‚¢":""}',
      \ },
      \ 'separator': { 'left': 'î‚°', 'right': 'î‚²' },
      \ 'subseparator': { 'left': 'î‚±', 'right': 'î‚³' }
      \ }
 
let g:lightline = {
      \ 'colorscheme': 'jellybeans',
      \ 'active': {
      \   'left': [ [ 'mode', 'paste' ], [ 'fugitive', 'filename' ], ['ctrlpmark'] ],
      \   'right': [ [ 'syntastic', 'lineinfo' ], ['percent'], [ 'fileformat', 'fileencoding', 'filetype' ] ]
      \ },
      \ 'component': {
      \   'readonly': '%{&readonly?"î‚¢":""}',
      \ },
      \ 'component_function': {
      \   'fugitive': 'MyFugitive',
      \   'filename': 'MyFilename',
      \   'fileformat': 'MyFileformat',
      \   'filetype': 'MyFiletype',
      \   'fileencoding': 'MyFileencoding',
      \   'mode': 'MyMode',
      \   'ctrlpmark': 'CtrlPMark',
      \ },
      \ 'component_expand': {
      \   'syntastic': 'SyntasticStatuslineFlag',
      \ },
      \ 'component_type': {
      \   'syntastic': 'error',
      \ },
      \ 'separator': { 'left': 'î‚°', 'right': 'î‚²' },
      \ 'subseparator': { 'left': 'î‚±', 'right': 'î‚³' }
      \ }

function! MyModified()
  return &ft =~ 'help' ? '' : &modified ? '+' : &modifiable ? '' : '-'
endfunction

function! MyReadonly()
  return &ft !~? 'help' && &readonly ? 'RO' : ''
endfunction

function! MyFilename()
  let fname = expand('%:t')
  return fname == 'ControlP' ? g:lightline.ctrlp_item :
        \ fname == '__Tagbar__' ? g:lightline.fname :
        \ fname =~ '__Gundo\|NERD_tree' ? '' :
        \ &ft == 'vimfiler' ? vimfiler#get_status_string() :
        \ &ft == 'unite' ? unite#get_status_string() :
        \ &ft == 'vimshell' ? vimshell#get_status_string() :
        \ ('' != MyReadonly() ? MyReadonly() . ' ' : '') .
        \ ('' != fname ? fname : '[No Name]') .
        \ ('' != MyModified() ? ' ' . MyModified() : '')
endfunction

function! MyFugitive()
  try
    if expand('%:t') !~? 'Tagbar\|Gundo\|NERD' && &ft !~? 'vimfiler' && exists('*fugitive#head')
      let mark = ''  " edit here for cool mark
      let _ = fugitive#head()
      return strlen(_) ? mark._ : ''
    endif
  catch
  endtry
  return ''
endfunction

function! MyFileformat()
  return winwidth(0) > 70 ? &fileformat : ''
endfunction

function! MyFiletype()
  return winwidth(0) > 70 ? (strlen(&filetype) ? &filetype : 'no ft') : ''
endfunction

function! MyFileencoding()
  return winwidth(0) > 70 ? (strlen(&fenc) ? &fenc : &enc) : ''
endfunction

function! MyMode()
  let fname = expand('%:t')
  return fname == '__Tagbar__' ? 'Tagbar' :
        \ fname == 'ControlP' ? 'CtrlP' :
        \ fname == '__Gundo__' ? 'Gundo' :
        \ fname == '__Gundo_Preview__' ? 'Gundo Preview' :
        \ fname =~ 'NERD_tree' ? 'NERDTree' :
        \ &ft == 'unite' ? 'Unite' :
        \ &ft == 'vimfiler' ? 'VimFiler' :
        \ &ft == 'vimshell' ? 'VimShell' :
        \ winwidth(0) > 60 ? lightline#mode() : ''
endfunction

function! CtrlPMark()
  if expand('%:t') =~ 'ControlP'
    call lightline#link('iR'[g:lightline.ctrlp_regex])
    return lightline#concatenate([g:lightline.ctrlp_prev, g:lightline.ctrlp_item
          \ , g:lightline.ctrlp_next], 0)
  else
    return ''
  endif
endfunction

let g:ctrlp_status_func = {
  \ 'main': 'CtrlPStatusFunc_1',
  \ 'prog': 'CtrlPStatusFunc_2',
  \ }

function! CtrlPStatusFunc_1(focus, byfname, regex, prev, item, next, marked)
  let g:lightline.ctrlp_regex = a:regex
  let g:lightline.ctrlp_prev = a:prev
  let g:lightline.ctrlp_item = a:item
  let g:lightline.ctrlp_next = a:next
  return lightline#statusline(0)
endfunction

function! CtrlPStatusFunc_2(str)
  return lightline#statusline(0)
endfunction

let g:tagbar_status_func = 'TagbarStatusFunc'

function! TagbarStatusFunc(current, sort, fname, ...) abort
    let g:lightline.fname = a:fname
  return lightline#statusline(0)
endfunction

augroup AutoSyntastic
  autocmd!
  autocmd BufWritePost *.c,*.cpp call s:syntastic()
augroup END
function! s:syntastic()
  SyntasticCheck
  call lightline#update()
endfunction

let g:unite_force_overwrite_statusline = 0
let g:vimfiler_force_overwrite_statusline = 0
let g:vimshell_force_overwrite_statusline = 0

" set statusline=%<     " è¡ŒãŒé•·ã™ãã‚‹ã¨ãã«åˆ‡ã‚Šè©°ã‚ã‚‹ä½ç½®
" set statusline+=[%n]  " ãƒãƒƒãƒ•ã‚¡ç•ªå·
" set statusline+=%m    " %m ä¿®æ­£ãƒ•ãƒ©ã‚°
" set statusline+=%r    " %r èª­ã¿è¾¼ã¿å°‚ç”¨ãƒ•ãƒ©ã‚°
" set statusline+=%h    " %h ãƒ˜ãƒ«ãƒ—ãƒãƒƒãƒ•ã‚¡ãƒ•ãƒ©ã‚°
" set statusline+=%w    " %w ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒ•ãƒ©ã‚°
" set statusline+=%{'['.(&fenc!=''?&fenc:&enc).':'.&ff.']'}  " fencã¨ffã‚’è¡¨ç¤º
" set statusline+=%y    " ãƒãƒƒãƒ•ã‚¡å†…ã®ãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚¿ã‚¤ãƒ—
" set statusline+=\     " ç©ºç™½ã‚¹ãƒšãƒ¼ã‚¹
" if winwidth(0) >= 130
"     set statusline+=%F    " ãƒãƒƒãƒ•ã‚¡å†…ã®ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ•ãƒ«ãƒ‘ã‚¹
" else
"     set statusline+=%t    " ãƒ•ã‚¡ã‚¤ãƒ«åã®ã¿
" endif
" set statusline+=%=    " å·¦å¯„ã›é …ç›®ã¨å³å¯„ã›é …ç›®ã®åŒºåˆ‡ã‚Š
" set statusline+=%{fugitive#statusline()}  " Gitã®ãƒ–ãƒ©ãƒ³ãƒåã‚’è¡¨ç¤º
" set statusline+=\ \   " ç©ºç™½ã‚¹ãƒšãƒ¼ã‚¹2å€‹
" set statusline+=%1l   " ä½•è¡Œç›®ã«ã‚«ãƒ¼ã‚½ãƒ«ãŒã‚ã‚‹ã‹
" set statusline+=/
" set statusline+=%L    " ãƒãƒƒãƒ•ã‚¡å†…ã®ç·è¡Œæ•°
" set statusline+=,
" set statusline+=%c    " ä½•åˆ—ç›®ã«ã‚«ãƒ¼ã‚½ãƒ«ãŒã‚ã‚‹ã‹
" set statusline+=%V    " ç”»é¢ä¸Šã®ä½•åˆ—ç›®ã«ã‚«ãƒ¼ã‚½ãƒ«ãŒã‚ã‚‹ã‹
" set statusline+=\ \   " ç©ºç™½ã‚¹ãƒšãƒ¼ã‚¹2å€‹
" set statusline+=%P    " ãƒ•ã‚¡ã‚¤ãƒ«å†…ã®ä½•ï¼…ã®ä½ç½®ã«ã‚ã‚‹ã‹

" }}}

" æ—¥æœ¬èªé–¢é€£ {{{

" æ–‡å­—ã‚³ãƒ¼ãƒ‰åˆ¤å®šé †åº
set fileencodings=utf-8,euc-jp,iso-2022-jp,cp932

" }}}

" ã‚·ãƒ³ã‚¿ãƒƒã‚¯ã‚¹ {{{
syntax enable
" }}}

" NeoBundle {{{
NeoBundleFetch 'Shougo/neobundle.vim'

" Vim Procã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
NeoBundle 'Shougo/vimproc',{'build': 
\ {
\   'windows': 'make -f make_windows.mak',
\   'cygwin': 'make -f make_cygwin.mak',
\   'mac': 'make -f make_mac.mak',
\   'unix': 'make -f make_unix.mak',
\ }
\}

NeoBundleLazy 'thinca/vim-quickrun', {
            \ 'autoload' : {
            \     'commands' : [ 'QuickRun' ]
            \  }
            \}

NeoBundleLazy 'Shougo/vimfiler.vim', {
\   'autoload' : { 'commands' : [ 'VimFiler', 'VimFilerTab', 'VimFilerExplorer', 'VimFilerBufferDir', 'VimFilerCreate' ] },
\   'depends': [ 'Shougo/unite.vim' ],
\ }

NeoBundleLazy 'Shougo/unite.vim' , {
\   'autoload' : { 'commands' : [ 'Unite' ] }
\ }

" VimShell
NeoBundleLazy 'Shougo/vimshell', {'depends': ['Shougo/vimproc']}


" Uniteãƒ—ãƒ©ã‚°ã‚¤ãƒ³
NeoBundleLazy 'Shougo/unite-outline'
" NeoBundleLazy 'ujihisa/unite-colorscheme'
NeoBundleLazy 'tacroe/unite-mark'
NeoBundleLazy 'osyo-manga/unite-fold'
" NeoBundleLazy 'taka84u9/unite-git'
" NeoBundleLazy 'thinca/vim-unite-history'
" NeoBundleLazy 'kannokanno/unite-dwm'
NeoBundleLazy 'tsukkee/unite-tag'


NeoBundleLazy 'thinca/vim-ref', {
\ 'autoload' : {'commands': [ 'Ref' ] },
\ 'depends' : ["mfumi/ref-dicts-en"]
\}
NeoBundleLazy 'mfumi/ref-dicts-en'

"
" ãƒ¡ãƒ¢å¸³
"
" @See https://sites.google.com/site/fudist/Home/qfixhowm/install
NeoBundleLazy 'fuenor/qfixgrep'
NeoBundleLazy 'fuenor/qfixhowm'
NeoBundleLazy "osyo-manga/unite-qfixhowm"


NeoBundleLazy "sjl/gundo.vim", {"autoload": {"commands": ['GundoToggle'],}}
NeoBundleLazy 'majutsushi/tagbar', {"autload": {"commands": ["TagbarToggle"],}}

NeoBundleLazy 'plasticboy/vim-markdown', {"autoload": {"filetypes": ["markdown"]}}

" ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆã‚’ã‚ã‹ã‚Šã‚„ã™ãã™ã‚‹
NeoBundleLazy  'nathanaelkane/vim-indent-guides'

" VimTemplate
NeoBundleLazy "thinca/vim-template"


" ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªå˜ä½ã§ã®vimrcã‚’æœ‰åŠ¹ã«ã™ã‚‹
NeoBundleLazy 'thinca/vim-localrc'

" ctagsã‚’è‡ªå‹•åŒ–
NeoBundleLazy 'soramugi/auto-ctags.vim'

"
" ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ç”¨
"
" HTML5ã‚·ãƒ³ã‚¿ãƒƒã‚¯ã‚¹ã‚’æœ‰åŠ¹ã«ã™ã‚‹
NeoBundleLazy 'othree/html5.vim.git', {"autoload": {"filetypes": ['html']}}

" CoffeeScriptç”¨ãƒ—ãƒ©ã‚°ã‚¤ãƒ³
NeoBundleLazy 'kchmck/vim-coffee-script', {"autoload": {"filetype": ["coffee"]}}

" Align
NeoBundleLazy 'h1mesuke/vim-alignta.git', {"autoload": {"commands": ["Align"]}}

" TagList
NeoBundleLazy 'taglist.vim'

" ã‚¿ã‚°ã‚¸ãƒ£ãƒ³ãƒ—
NeoBundleLazy  'szw/vim-tags'

"Dockerfile Syntax
NeoBundleLazy 'ekalinin/Dockerfile.vim', {"autoload": {"filetype": ["dockerfile"]}}

"Vagrant Syntax
NeoBundleLazy 'markcornick/vim-vagrant', {"autoload": {"filetype": ["vagrantfile"]}}

"Tmux Syntax
NeoBundleLazy 'Keithbsmiley/tmux.vim', {"autoload": {"filetype": ["tmux"]}}

" Powerline
NeoBundleLazy 'Lokaltog/powerline', { 'rtp' : 'powerline/bindings/vim' }
NeoBundleLazy 'Lokaltog/powerline-fontpatcher'

" HTMLé–‰ã˜ã‚¿ã‚°å¾Œã®ã‚³ãƒ¡ãƒ³ãƒˆã‚’,tã§å…¥åŠ›
NeoBundleLazy 'haya14busa/endtagcomment.vim', {"autoload": {"filetype": ["html"]}}

" ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆç®¡ç†
" NeoBundle 'project.vim'
NeoBundleLazy 'kien/ctrlp.vim', {"autoload": {"commands": ["CtrlP", "CtrlPMRUFiles"]}}

" ãƒ¡ãƒ¢
NeoBundleLazy 'glidenote/memolist.vim', {"autoload": {"commands": ["MemoList"]}}

" }}}

" è¨­å®š {{{
NeoBundle 'kana/vim-textobj-user'

" Submoduleã‚’æœ‰åŠ¹ã«ã™ã‚‹
NeoBundle  'kana/vim-submode'

" Gitã‚’ä¾¿åˆ©ã«ä½¿ã†
NeoBundle 'tpope/vim-fugitive'

" ã‚³ãƒ¡ãƒ³ãƒˆON/OFFã‚’æ‰‹è»½ã«å®Ÿè¡Œ (gcc)
NeoBundle 'tomtom/tcomment_vim'

" Tabå˜ä½ã§ã®cdã‚’æœ‰åŠ¹ã«ã™ã‚‹
NeoBundle 'kana/vim-tabpagecd'

" ã‚«ãƒ©ãƒ¼ã‚¹ã‚­ãƒ¼ãƒ
NeoBundle 'nanotech/jellybeans.vim'
let s:bundle = neobundle#get('jellybeans.vim')
function! s:bundle.hooks.on_source(bundle)
    colorscheme jellybeans
endfunction

" Undoã‚’ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‰ã˜ãŸå¾Œã‚‚æœ‰åŠ¹ã«ã™ã‚‹
if has('persistent_undo')
    set undofile
    set undodir=$HOME/.vim.tmp
endif 

" ã‚­ãƒ¼ãƒã‚¤ãƒ³ãƒ‰ {{{

" é–“é•ãˆãã†ãªãƒã‚¤ãƒ³ãƒ‰ã‚’èª¿æ•´(äº‹æ•…ã®ç´ ) {{{
nnoremap ZZ <Nop>
nnoremap ZQ <Nop>
nnoremap Q <Nop>
inoremap <F1> <ESC>
nnoremap <F1> <ESC>
vnoremap <F1> <ESC>
nnoremap ; :
cmap w1 w! 
cmap q1 q! 
" }}}

" VIã‚’ã‚‚ã£ã¨ç›´æ„Ÿçš„ã«ã™ã‚‹ {{{
nnoremap j gj
nnoremap k gk
nnoremap gj j
nnoremap gk k
inoremap jj <ESC>

" ã‚«ãƒ¼ã‚½ãƒ«ä¸‹ã®å˜èªã‚’ * ã§æ¤œç´¢
vnoremap <silent> * "vy/\V<C-r>=substitute(escape(@v, '\/'), "\n", '\\n', 'g')<CR><CR>

" æ¤œç´¢å¾Œã«ã‚¸ãƒ£ãƒ³ãƒ—ã—ãŸéš›ã«æ¤œç´¢å˜èªã‚’ç”»é¢ä¸­å¤®ã«æŒã£ã¦ãã‚‹
nnoremap n nzz
nnoremap N Nzz
nnoremap * *zz
nnoremap # #zz
nnoremap g* g*zz
nnoremap g# g#zz

" vã‚’äºŒå›ã§è¡Œæœ«ã¾ã§é¸æŠ
vnoremap v $h

set showmatch           " å¯¾å¿œã™ã‚‹æ‹¬å¼§ãªã©ã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆè¡¨ç¤ºã™ã‚‹
set matchtime=3         " å¯¾å¿œæ‹¬å¼§ã®ãƒã‚¤ãƒ©ã‚¤ãƒˆè¡¨ç¤ºã‚’3ç§’ã«ã™ã‚‹
" å¯¾å¿œæ‹¬å¼§ã«'<'ã¨'>'ã®ãƒšã‚¢ã‚’è¿½åŠ 
set matchpairs& matchpairs+=<:>
" ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆä¸å¯è¦–æ–‡å­—ã¯ç¾ã—ããªã„ã®ã§Unicodeã§ç¶ºéº—ã«
set listchars=tab:Â»-,trail:-,extends:Â»,precedes:Â«,nbsp:%,eol:â†²
" }}}

" ãƒã‚¦ã‚¹ã®è¨­å®š {{{

" ãƒã‚¦ã‚¹ã®æœ‰åŠ¹ç„¡åŠ¹
nnoremap <F3> :call ToggleMouse()<CR>
inoremap <F3> :call ToggleMouse()<CR>
function! ToggleMouse()
	if &mouse == 'a'
		set mouse =
		echo "Mouse usage disabled"
	else
		set mouse=a
		echo "Mouse usage enabled"
	endif
endfunction
" }}}

" ãƒ¢ãƒ¼ãƒ‰ãƒˆã‚°ãƒ« {{{
nmap <silent> [nora:mode]p :<C-u>set paste!<CR>
nmap <silent> [nora:mode]m :<C-u>call ToggleMouse()<CR>
" }}}

" w!!ã§sudoçµŒç”±ã§ä¿å­˜
cmap w!! w !sudo tee > /dev/null %

" }}}

" ã‚¦ã‚¤ãƒ³ãƒ‰ã‚¦æ“ä½œç³» {{{

NeoBundle 'Shougo/neomru.vim'

nmap <silent> [nora]j <C-w>j
nmap <silent> [nora]k <C-w>k
nmap <silent> [nora]l <C-w>l
nmap <silent> [nora]h <C-w>h
nmap <silent> [nora]<C-j> <C-w>j
nmap <silent> [nora]<C-k> <C-w>k
nmap <silent> [nora]<C-l> <C-w>l
nmap <silent> [nora]<C-h> <C-w>h
nnoremap [nora]= <C-w>=
nnoremap [nora]> <C-w>>
nnoremap [nora]< <C-w><
nnoremap [nora]+ <C-w>+
nnoremap [nora]- <C-w>-
let s:bundle = neobundle#get("vim-submode")
function! s:bundle.hooks.on_source(bundle)
    call submode#enter_with('windowi', 'n', '', 's>', '<C-w>>')
    call submode#enter_with('windowi', 'n', '', 's<', '<C-w><')
    call submode#enter_with('windowi', 'n', '', 's+', '<C-w>+')
    call submode#enter_with('windowi', 'n', '', 's-', '<C-w>-')
    call submode#map('windowi', 'n', '', '>', '<C-w>>')
    call submode#map('windowi', 'n', '', '<', '<C-w><')
    call submode#map('windowi', 'n', '', '+', '<C-w>+')
    call submode#map('windowi', 'n', '', '-', '<C-w>-')
endfunction

" ã‚¨ã‚¯ã‚¹ãƒ—ãƒ­ãƒ¼ãƒ©ã‚’é–‹ã
nnoremap <silent> [nora:ext]e :<C-u>VimFilerCreate -split -simple -winwidth=35 -no-quit<CR>
nnoremap <silent> [nora]<C-e> :<C-u>VimFilerBufferDir -split -simple -winwidth=35 -no-quit<CR>

" ã‚¿ã‚°ãƒãƒ¼ã‚’é–‹ã
nnoremap <silent> [nora:ext]t :<C-u>TagbarToggle<CR>
" gundo
nnoremap <silent> [nora:ext]g :<C-u>GundoToggle<CR>


" }}}

" Uniteç³» {{{
nnoremap <silent> [nora]b :<C-u>Unite buffer bookmark<CR>
nnoremap <silent> [nora]o :<C-u>Unite fold outline<CR>
nnoremap <silent> [nora]<C-h> :<C-u>Unite buffer file_mru<CR>
nnoremap <silent> [nora]c :<C-u>UniteWithBufferDir file file/new directory/new<CR>
nnoremap <silent> [nora]q :<C-u>Unite qfixhowm qfixhowm/new <CR>
nnoremap <silent> [nora]<C-q> :<C-u>Unite qfixhowm qfixhowm/new <CR>
nnoremap <silent> [nora]<C-c> :<C-u>UniteWithBufferDir file file/new directory/new<CR>
nnoremap <silent> [nora]y :<C-u>Unite history/yank<CR>

let s:bundle = neobundle#get("unite.vim")
function! s:bundle.hooks.on_source(bundle)
    let g:unite_enable_start_insert=1
    let g:unite_source_history_yank_enable =1
    let g:unite_source_file_mru_limit = 200
endfunction


autocmd NoraAutoCmd FileType unite call s:unite_my_settings()
function! s:unite_my_settings()
    nnoremap <silent> <buffer> <expr> <C-T> unite#do_action('tabopen')
    inoremap <silent> <buffer> <expr> <C-T> unite#do_action('tabopen')
    nnoremap <silent> <buffer> <expr> t unite#do_action('tabopen')
    nnoremap <silent> <buffer> <expr> o unite#do_action('split')
    nnoremap <silent> <buffer> <expr> <C-O> unite#do_action('split')
    inoremap <silent> <buffer> <expr> <C-O> unite#do_action('split')
    nnoremap <silent> <buffer> <expr> <C-V> unite#do_action('vsplit')
    inoremap <silent> <buffer> <expr> <C-V> unite#do_action('vsplit')
    inoremap <silent> <buffer> <expr> <C-V> unite#do_action('vsplit')
    nnoremap <silent> <buffer> <ESC><ESC> :q<CR>
    inoremap <silent> <buffer> <ESC><ESC> <ESC>:q<CR>
    imap <buffer> <C-k>     <Plug>(unite_select_previous_line)
    imap <buffer> <C-j>     <Plug>(unite_select_next_line)
endfunction
" }}}

" ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ“ä½œ(CtrlP) {{{
let s:bundle = neobundle#get("ctrlp.vim")
function! s:bundle.hooks.on_source(bundle)
    let g:ctrlp_map = '<Nop>'
    let g:ctrlp_working_path_mode = 'ra'
    let g:ctrlp_open_new_file = 'r'
    let g:ctrlp_extensions = ['tag', 'quickfix', 'dir', 'line', 'mixed']
    let g:ctrlp_max_files  = 100000 " å¯¾è±¡ãƒ•ã‚¡ã‚¤ãƒ«æœ€å¤§æ•°(default:10000)
    let g:ctrlp_max_depth = 10 " æ¤œç´¢å¯¾è±¡ã®æœ€å¤§éšå±¤æ•°(default:40)
    let g:ctrlp_clear_cache_on_exit = 0 " vimçµ‚äº†æ™‚ã«ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¯ãƒªã‚¢ã—ãªã„(default:1)
    let g:ctrlp_match_window = 'bottom,order:btt,min:1,max:18,results:50' " æ¤œç´¢ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®è¨­å®š
endfunction
nnoremap [nora]m :<C-u>CtrlPMRUFiles<CR> 
" }}}

" HTMLæ“ä½œ {{{
nmap [nora]et <Plug>(endtagcomment)
" }}}

" è¾æ›¸: vim-ref {{{
" vimshell% cd ~/.vim/
" vimshell% curl -sSL "http://jp1.php.net/get/php_manual_ja.tar.gz/from/this/mirror" | tar zxvf -
"
nnoremap [ref] <Nop>
nmap [nora]r [ref]

"Ref webdictã§alcã‚’ä½¿ã†è¨­å®š
let g:ref_source_webdict_cmd = 'lynx -dump -nonumbers %s'
"let g:ref_source_webdict_use_cache = 1
let g:ref_source_webdict_sites = {
            \ 'alc' : {
            \   'url' : 'http://eow.alc.co.jp/%s/UTF-8/',
            \   'cache' : 1
            \   },
            \ 'wiktionary' : {
            \   'url' : 'http://ja.wiktionary.org/wiki/%s',
            \   'keyword_encoding': 'utf-8',
            \   'cache' : 1
            \   }
            \ }
function! g:ref_source_webdict_sites.alc.filter(output)
      return join(split(a:output, "\n")[42 :], "\n")
endfunction

let g:ref_phpmanual_path = "/opt/vim/php-chunked-xhtml/"
nmap [ref]a :<C-u>Ref webdict alc 
nmap [ref]w :<C-u>Ref webdict wiktionary 
nmap [ref]p :<C-u>Ref phpmanual 
" }}}

" ãƒ¡ãƒ¢ {{{

" memolist {{{
let g:memolist_qfixgrep = 1
let g:memolist_memo_suffix = "md"
let g:memolist_memo_date = "%Y-%m-%d %H:%M"
let g:memolist_memo_date = "epoch"
let g:memolist_memo_date = "%d %t"
let g:memolist_prompt_tags = 1
let g:memolist_prompt_categories = 1
let g:memolist_qfixgrep = 1
let g:memolist_vimfiler = 1
let g:memolist_template_dir_path = "~/memo/memolist"
map [nora:ext]ml  :MemoList<cr>
map [nora:ext]mn  :MemoNew<cr>
map [nora:ext]mg  :MemoGrep<cr>
" }}}

" QFixHowm {{{
" ãƒ¡ãƒ¢æ©Ÿèƒ½
"set QFixHowm_Key = '<nop>'
 
let howm_dir             = '~/memo/hown'

" ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³è¨˜æ³•ã‚’ä½¿ã†
"let QFixHowm_FileType = 'markdown'
"let QFixHowm_Title = '#'
"let QFixMRU_Title = {}
"let QFixMRU_Title['mkd']       = '^###[^#]'
"let QFixMRU_Title['mkd_regxp'] = '^###[^#]'
au BufRead,BufNewFile *.md set filetype=markdown

" ãƒ•ã‚¡ã‚¤ãƒ«æ‹¡å¼µå­ã‚’mdã«ã™ã‚‹
let howm_filename = '%Y/%m/%Y-%m-%d-%H%M%S.md'
" ãƒ•ã‚¡ã‚¤ãƒ«ã‚¿ã‚¤ãƒ—ã‚’markdownã«ã™ã‚‹
let QFixHowm_FileType = 'markdown'
" ã‚¿ã‚¤ãƒˆãƒ«è¨˜å·
" let QFixHowm_Title = '#'
" ã‚¿ã‚¤ãƒˆãƒ«è¡Œæ¤œç´¢æ­£è¦è¡¨ç¾ã®è¾æ›¸ã‚’åˆæœŸåŒ–
let QFixMRU_Title = {}
" MRUã§ã‚¿ã‚¤ãƒˆãƒ«è¡Œã¨ã¿ãªã™æ­£è¦è¡¨ç¾(Vimã®æ­£è¦è¡¨ç¾ã§æŒ‡å®š)
let QFixMRU_Title['mkd'] = '^###[^#]'
" grepã§ã‚¿ã‚¤ãƒˆãƒ«è¡Œã¨ã¿ãªã™æ­£è¦è¡¨ç¾(ä½¿ç”¨ã™ã‚‹grepã«ã‚ˆã£ã¦ã¯å¤‰æ›´ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™)
let QFixMRU_Title['mkd_regxp'] = '^###[^#]'
" }}}

" }}}

" Grepç³» {{{
nnoremap <silent> [search] :<C-u>Unite grep:. -buffer-name=search-buffer<CR>
" ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã®å˜èªã§æ¤œç´¢
nnoremap <silent> [search]j :<C-u>Unite grep:. -buffer-name=search-buffer<CR><C-R><C-W><CR>
" æ¤œç´¢ã®å†é–‹
nnoremap <silent> [search]k :<C-u>UniteResume search-buffer<CR>
" }}}

" Gitç³» {{{
nnoremap  [nora:ext]s :<C-u>Git status<CR>
nnoremap  [nora:ext]p :<C-u>Git push<CR>
nnoremap  [nora:ext]a :<C-u>Git add %<CR>
nnoremap  [nora:ext]c :<C-u>Git commit<CR>
nnoremap  [nora:ext]d :<C-u>Git diff %<CR>
" }}}

" Snippet {{{
" ã‚¹ãƒ‹ãƒšãƒƒãƒˆ
NeoBundle 'Shougo/neosnippet'
NeoBundle 'Shougo/neosnippet-snippets'

" Plugin key-mappings.
imap <C-k>     <Plug>(neosnippet_expand_or_jump)
smap <C-k>     <Plug>(neosnippet_expand_or_jump)
xmap <C-k>     <Plug>(neosnippet_expand_target)
 
" SuperTab like snippets behavior.
" imap <expr><TAB> neosnippet#expandable_or_jumpable() ?
" \ "\<Plug>(neosnippet_expand_or_jump)"
" \: pumvisible() ? "\<C-n>" : "\<TAB>"
" smap <expr><TAB> neosnippet#expandable_or_jumpable() ?
" \ "\<Plug>(neosnippet_expand_or_jump)"
" \: "\<TAB>"

let g:neosnippet#snippets_directory='~/.dotfiles/vim/snippets/'
nnoremap [snipet] <nop>
nmap [nora]s [snipet]
nnoremap <silent> [snipet]e :<c-u>NeoSnippetEdit<cr>
nnoremap <silent> [snipet] :<c-u>NeoSnippetEdit<cr>

" For snippet_complete marker.
if has('conceal')
  set conceallevel=2 concealcursor=i
endif

" }}}

" è£œå®Œ {{{
" Luaã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®æœ‰ç„¡ã§ä½¿ç”¨ã™ã‚‹ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚’å¤‰æ›´
function! s:meet_neocomplete_requirements()
	return has('lua') && (v:version > 703 || (v:version == 703 && has('patch885')))
endfunction

if s:meet_neocomplete_requirements()
	NeoBundle 'Shougo/neocomplete.vim'
	NeoBundleFetch 'Shougo/neocomplcache.vim'
else
	NeoBundleFetch 'Shougo/neocomplete.vim'
	NeoBundle 'Shougo/neocomplcache.vim'
endif

if neobundle#is_installed('neocomplete')
	let g:neocomplcate#enable_at_startup=1
endif
if neobundle#is_installed('neocomplcache')
	let g:neocomplcache#enable_at_startup=1
endif

"Note: This option must set it in .vimrc(_vimrc).  NOT IN .gvimrc(_gvimrc)!
" Disable AutoComplPop.
let g:acp_enableAtStartup = 0
" Use neocomplete.
if s:meet_neocomplete_requirements()
	" æ–°ã—ãè¿½åŠ ã—ãŸ neocomplete ã®è¨­å®š
	let g:neocomplete#enable_at_startup = 1
	" Use smartcase.
	let g:neocomplete#enable_smart_case = 1
	" Set minimum syntax keyword length.
	let g:neocomplete#sources#syntax#min_keyword_length = 3
	let g:neocomplete#lock_buffer_name_pattern = '\*ku\*'

	" Define dictionary.
	let g:neocomplete#sources#dictionary#dictionaries = {
		\ 'default' : '',
		\ 'vimshell' : $HOME.'/.vimshell_hist',
		\ 'scheme' : $HOME.'/.gosh_completions'
			\ }

	" Define keyword.
	if !exists('g:neocomplete#keyword_patterns')
		let g:neocomplete#keyword_patterns = {}
	endif
	let g:neocomplete#keyword_patterns['default'] = '\h\w*'

	" Plugin key-mappings.
	inoremap <expr><C-g>     neocomplete#undo_completion()
	inoremap <expr><C-l>     neocomplete#complete_common_string()

	" Recommended key-mappings.
	" <CR>: close popup and save indent.
	inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
	function! s:my_cr_function()
	  return neocomplete#close_popup() . "\<CR>"
	  " For no inserting <CR> key.
	  "return pumvisible() ? neocomplete#close_popup() : "\<CR>"
	endfunction
	" <TAB>: completion.
	inoremap <expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"
	" <C-h>, <BS>: close popup and delete backword char.
	inoremap <expr><C-h> neocomplete#smart_close_popup()."\<C-h>"
	inoremap <expr><BS> neocomplete#smart_close_popup()."\<C-h>"
	inoremap <expr><C-y>  neocomplete#close_popup()
	inoremap <expr><C-e>  neocomplete#cancel_popup()
	" Close popup by <Space>.
	"inoremap <expr><Space> pumvisible() ? neocomplete#close_popup() : "\<Space>"

	" For cursor moving in insert mode(Not recommended)
	"inoremap <expr><Left>  neocomplete#close_popup() . "\<Left>"
	"inoremap <expr><Right> neocomplete#close_popup() . "\<Right>"
	"inoremap <expr><Up>    neocomplete#close_popup() . "\<Up>"
	"inoremap <expr><Down>  neocomplete#close_popup() . "\<Down>"
	" Or set this.
	"let g:neocomplete#enable_cursor_hold_i = 1
	" Or set this.
	"let g:neocomplete#enable_insert_char_pre = 1

	" AutoComplPop like behavior.
	"let g:neocomplete#enable_auto_select = 1

	" Shell like behavior(not recommended).
	"set completeopt+=longest
	"let g:neocomplete#enable_auto_select = 1
	"let g:neocomplete#disable_auto_complete = 1
	"inoremap <expr><TAB>  pumvisible() ? "\<Down>" : "\<C-x>\<C-u>"

	" Enable omni completion.
	autocmd NoraAutoCmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
	autocmd NoraAutoCmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
	autocmd NoraAutoCmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
	autocmd NoraAutoCmd FileType python setlocal omnifunc=pythoncomplete#Complete
	autocmd NoraAutoCmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags

	" Enable heavy omni completion.
	if !exists('g:neocomplete#sources#omni#input_patterns')
	  let g:neocomplete#sources#omni#input_patterns = {}
	endif
	"let g:neocomplete#sources#omni#input_patterns.php = '[^. \t]->\h\w*\|\h\w*::'
	"let g:neocomplete#sources#omni#input_patterns.c = '[^.[:digit:] *\t]\%(\.\|->\)'
	"let g:neocomplete#sources#omni#input_patterns.cpp = '[^.[:digit:] *\t]\%(\.\|->\)\|\h\w*::'

	" For perlomni.vim setting.
	" https://github.com/c9s/perlomni.vim
	let g:neocomplete#sources#omni#input_patterns.perl = '\h\w*->\h\w*\|\h\w*::'
else
	" ä»Šã¾ã§ã® neocomplcache ã®è¨­å®š
endif
" }}}

" Vimshell {{{

":VimShell [{options}...] [{path}]		*:VimShell*
":VimShellCreate [{options}...] [{path}]		*:VimShellCreate*
":VimShellTab [{options}...] [{path}]		*:VimShellTab*
":VimShellPop [{options}...] [{path}]		*:VimShellPop*
":VimShellCurrentDir [{options}...] [{path}]	*:VimShellCurrentDir*
":VimShellBufferDir [{options}...] [{path}]	*:VimShellBufferDir*
":VimShellExecute [{option}] [{command}]			*:VimShellExecute*
":VimShellInteractive [{option}] [{command}]		*:VimShellInteractive*
":[range]VimShellSendString {string}		*:VimShellSendString*
":VimShellSendBuffer {bufname}			*:VimShellSendBuffer*
":VimShellClose [{buffer-name}]			*:VimShellClose*

" }}}


" }}}

" Hack {{{

" Use vsplit mode
if has("vim_starting") && !has('gui_running') && has('vertsplit')
 function! g:EnableVsplitMode()
   " enable origin mode and left/right margins
   let &t_CS = "y"
   let &t_ti = &t_ti . "\e[?6;69h"
   let &t_te = "\e[?6;69l\e[999H" . &t_te
   let &t_CV = "\e[%i%p1%d;%p2%ds"
   call writefile([ "\e[?6;69h" ], "/dev/tty", "a")
 endfunction

 " old vim does not ignore CPR
 map <special> <Esc>[3;9R <Nop>

 " new vim can't handle CPR with direct mapping
 " map <expr> ^[[3;3R g:EnableVsplitMode()
 set t_F9=[3;3R
 map <expr> <t_F9> g:EnableVsplitMode()
 let &t_RV .= "\e[?6;69h\e[1;3s\e[3;9H\e[6n\e[0;0s\e[?6;69l"
endif

command! -nargs=0 JunkFile call s:open_junk_file()
function! s:open_junk_file()
    let l:junk_dir = $HOME . '/.vim_junk'. strftime('/%Y/%m')
    if !isdirectory(l:junk_dir)
        call mkdir(l:junk_dir, 'p')
    endif

    let l:filename = input('Junk Code: ', l:junk_dir.strftime('/%Y-%m-%d-%H%M%S.'))
    if l:filename != ''
        execute 'edit ' . l:filename
    endif
endfunction

" }}}

" Quickrun {{{

let s:bundle = neobundle#get("vim-quickrun")
let g:quickrun_config = {
\   "_" : {
\       "hook/close_unite_quickfix/enable_hook_loaded" : 1,
\       "hook/unite_quickfix/enable_failure" : 1,
\       "hook/close_quickfix/enable_exit" : 1,
\       "hook/close_buffer/enable_failure" : 1,
\       "hook/close_buffer/enable_empty_data" : 1,
\       "runner" : "vimproc",
\       "runner/vimproc/updatetime" : 60,
\       "outputter" : "multi:buffer:quickfix",
\       "outputter/buffer/split" : ":botright 18sp",
\   },
\}

nnoremap <silent> [nora:ext]r : <C-u>QuickRun<CR>

" }}}

" ãƒã‚ªãƒãƒ³ãƒ‰ãƒ«ç”¨ã®çµ‚äº† {{{
call neobundle#end()
filetype plugin indent on
" }}}
